var documenterSearchIndex = {"docs":
[{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"EditURL = \"../../../examples/electronic_current.jl\"","category":"page"},{"location":"examples/electronic_current/#Electronic-Current","page":"Electronic Current","title":"Electronic Current","text":"","category":"section"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"In this example, we demonstrate how to compute an environmental observable: the electronic current.","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"using HierarchicalEOM\nimport LinearAlgebra: tr\nimport Plots","category":"page"},{"location":"examples/electronic_current/#Hamiltonian","page":"Electronic Current","title":"Hamiltonian","text":"","category":"section"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"We consider a single-level charge system coupled to two [left (L) and right (R)] fermionic reservoirs (textrmf). The total Hamiltonian is given by H_textrmT=H_textrms+H_textrmf+H_textrmsf, where each terms takes the form","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"beginaligned\nH_textrms  = epsilon d^dagger d\nH_textrmf  =sum_alpha=textrmLtextrmRsum_kepsilon_alphakc_alphak^daggerc_alphak\nH_textrmsf =sum_alpha=textrmLtextrmRsum_kg_alphakc_alphak^daggerd + g_alphak^* d^daggerc_alphak\nendaligned","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"Here, d (d^dagger) annihilates (creates) an electron in the system and epsilon is the energy of the electron. Furthermore, c_alphak (c_alphak^dagger) annihilates (creates) an electron in the state k (with energy epsilon_alphak) of the alpha-th reservoir.","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"Now, we can construct the system Hamiltonian","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"d = [0 1; 0 0] ## annihilation operator of the system electron\n\n# The system Hamiltonian\nϵ = 1. # site energy\nHsys = ϵ * d' * d\n\n# System initial state\nρ0 = [1 0; 0 0];\nnothing #hide","category":"page"},{"location":"examples/electronic_current/#Construct-bath-objects","page":"Electronic Current","title":"Construct bath objects","text":"","category":"section"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"We assume the fermionic reservoir to have a Lorentzian-shaped spectral density, and we utilize the Padé decomposition. Furthermore, the spectral densities depend on the following physical parameters:","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"the coupling strength Gamma between system and reservoirs\nthe band-width W\nthe temperature T\nthe chemical potential mu\nthe total number of exponentials for the reservoir 2(N + 1)","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"Γ = 0.01\nW = 1\nT = 0.025851991\nμL =  1.  # Left  bath\nμR = -1.  # Right bath\nN = 2\nbath_L = Fermion_Lorentz_Pade(d, Γ, μL, W, T, N)\nbath_R = Fermion_Lorentz_Pade(d, Γ, μR, W, T, N)\nbaths = [bath_L, bath_R]","category":"page"},{"location":"examples/electronic_current/#Construct-HEOMLS-matrix","page":"Electronic Current","title":"Construct HEOMLS matrix","text":"","category":"section"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"(see also HEOMLS Matrix for Fermionic Baths)","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"tier = 5\nM = M_Fermion(Hsys, tier, baths)","category":"page"},{"location":"examples/electronic_current/#Solve-time-evolution-of-ADOs","page":"Electronic Current","title":"Solve time evolution of ADOs","text":"","category":"section"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"(see also Time Evolution)","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"tlist = 0:0.5:100\nados_evolution = evolution(M, ρ0, tlist);\nnothing #hide","category":"page"},{"location":"examples/electronic_current/#Solve-stationary-state-of-ADOs","page":"Electronic Current","title":"Solve stationary state of ADOs","text":"","category":"section"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"(see also Stationary State)","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"ados_steady = SteadyState(M);\nnothing #hide","category":"page"},{"location":"examples/electronic_current/#Calculate-current","page":"Electronic Current","title":"Calculate current","text":"","category":"section"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"Within the influence functional approach, the expectation value of the electronic current from the alpha-fermionic bath into the system can be written in terms of the first-level-fermionic (n=1) auxiliary density operators, namely","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"langle I_alpha(t) rangle =(-e) fracdlangle mathcalN_alpharangledt=i e sum_qintextbfq(-1)^delta_nu- textrmTrleftd^barnurho^(01+)_vert textbfq(t)right","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"where e represents the value of the elementary charge, and mathcalN_alpha=sum_k c^dagger_alphakc_alphak is the occupation number operator for the alpha-fermionic bath.","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"Given an ADOs, we provide a function which calculates the current from the alpha-fermionic bath into the system with the help of Hierarchy Dictionary.","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"bathIdx:","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"1 means 1st bath (bath_L)\n2 means 2nd bath (bath_R)","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"function Ic(ados, M::M_Fermion, bathIdx::Int)\n    # the hierarchy dictionary\n    HDict = M.hierarchy\n\n    # we need all the indices of ADOs for the first level\n    idx_list = HDict.lvl2idx[1]\n    I = 0.0im\n    for idx in idx_list\n        ρ1 = ados[idx]  ## 1st-level ADO\n\n        # find the corresponding bath index (α) and exponent term index (k)\n        nvec = HDict.idx2nvec[idx]\n        for (α, k, _) in getIndexEnsemble(nvec, HDict.bathPtr)\n            if α == bathIdx\n                exponent = M.bath[α][k]\n                if exponent.types == \"fA\"     ## fermion-absorption\n                    I += tr(exponent.op' * ρ1)\n                elseif exponent.types == \"fE\" ## fermion-emission\n                    I -= tr(exponent.op' * ρ1)\n                end\n                break\n            end\n        end\n    end\n\n    e = 1.60218e-19\n    ħ = 6.62607015e−34 / (2 * π)\n    eV_to_Joule = 1.60218e-19  ## unit conversion\n\n    # (e / ħ) * I  [change unit to μA]\n    return (e / ħ) * real(1im * I) * eV_to_Joule * 1e6\nend\n\n# steady current\nIs_L = ones(length(tlist)) .* Ic(ados_steady, M, 1)\nIs_R = ones(length(tlist)) .* Ic(ados_steady, M, 2)\n\n# time evolution current\nIe_L = []\nIe_R = []\nfor ados in ados_evolution\n    push!(Ie_L, Ic(ados, M, 1))\n    push!(Ie_R, Ic(ados, M, 2))\nend\n\nPlots.plot(\n    tlist,\n    [Ie_L, Ie_R, Is_L, Is_R],\n    label=[\"Bath L\" \"Bath R\" \"Bath L (Steady State)\" \"Bath R (Steady State)\"],\n    linecolor=[ :blue   :red :blue  :red],\n    linestyle=[:solid :solid :dash :dash],\n    linewidth=3,\n    xlabel=\"time\",\n    ylabel=\"Current\",\n    grid=false\n)","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"Note that this example can also be found in qutip documentation","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"","category":"page"},{"location":"examples/electronic_current/","page":"Electronic Current","title":"Electronic Current","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fermionic_bath/#doc-Fermionic-Bath","page":"Fermionic Bath","title":"Fermionic Bath","text":"","category":"section"},{"location":"fermionic_bath/#Fermionic-Bath-Introduction","page":"Fermionic Bath","title":"Introduction","text":"","category":"section"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"The FermionBath object describes the interaction between the system (s) and a exterior fermionic environment (f), which can be modeled by","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"H_sf=sum_k g_k c_k^dagger d_s + g_k^* c_k d_s^dagger","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"where g_k is the coupling strength and c_k (c_k^dagger) annihilates (creates) a fermion in the k-th state of the fermionic environment. Here, d_s refers to the system-interaction operator and should be an odd-parity operator destroying a fermion in the system.","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"The effects of a fermionic environment (initially in thermal equilibrium and linearly coupled to the system) are completely encoded in the two-time correlation functions, namely","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"C^nu(t_1t_2)\n=frac12piint_-infty^infty domega \nJ(omega)leftfrac1-nu2+nu n(omega)\nrighte^nu iomega (t_1-t_2)","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"where J(omega) is the spectral density of the bath and n(omega)=exp(omega-mu)k_B T+1^-1 represents the Fermi-Dirac distribution (with chemical potential mu). Here, nu=+ and nu=- denotes the absorption and emission process of the fermionic system, respectively.","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"A more practical representation can be found by expressing the correlation function as a sum of exponential terms (Exponent), namely","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"C^nu(t_1 t_2)=sum_i eta_i^nu e^-gamma_i^nu (t_1-t_2)","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"This allows us to define an iterative procedure which leads to the hierarchical equations of motion (HEOM).","category":"page"},{"location":"fermionic_bath/#Methods","page":"Fermionic Bath","title":"Methods","text":"","category":"section"},{"location":"fermionic_bath/#Construct-FermionBath","page":"Fermionic Bath","title":"Construct FermionBath","text":"","category":"section"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"One can construct the FermionBath object with the coupling operator ds::AbstractMatrix and the four lists η_absorb::AbstractVector, γ_absorb::AbstractVector, η_emit::AbstractVector and γ_emit::AbstractVector which correspond to the exponential terms eta_i^+_i, gamma_i^+_i, eta_i^-_i and gamma_i^-_i, respectively. ","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"bath = FermionBath(ds, η_absorb, γ_absorb, η_emit, γ_emit)","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"warning: Warning\nHere, the length of the four lists (η_absorb, γ_absorb, η_emit and γ_emit) should all be the same.","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"note: Note\nInstead of analytically solving the correlation function C^nu=pm(t_1 t_2) to obtain a sum of exponential terms, one can also use the built-in functions (for different spectral densities J(omega) and spectral decomposition methods, which have been analytically solved by the developers already) listed in the end of this page. ","category":"page"},{"location":"fermionic_bath/#Print-Fermionic-Bath","page":"Fermionic Bath","title":"Print Fermionic Bath","text":"","category":"section"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"One can check the information of the FermionBath by the print function, for example:","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"print(bath)","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"FermionBath object with (system) dim = 2 and 4 exponential-expansion terms","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"Note that FermionBath always have even number of exponential terms (half for C^nu=+ and half for C^nu=-)","category":"page"},{"location":"fermionic_bath/#Calculate-the-correlation-function","page":"Fermionic Bath","title":"Calculate the correlation function","text":"","category":"section"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"To check whether the exponential terms in the FermionBath is correct or not, one can call C(bath::FermionBath, tlist::AbstractVector) to calculate the correlation function C(t), where t=t_1-t_2:","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"cp_list, cm_list = C(bath, tlist)","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"Here, cp_list and cm_list are the lists which contain the value of C^nu=+(t) and C^nu=-(t) correspond to the given time series tlist, respectively.","category":"page"},{"location":"fermionic_bath/#Methods-for-Exponent","page":"Fermionic Bath","title":"Methods for Exponent","text":"","category":"section"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"HierarchicalEOM.jl also supports users to access the specific exponential term with brakets []. This returns an Exponent object, which contains the corresponding value of eta_i^nu and gamma_i^nu:","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"e = bath[2] # the 2nd-term\nprint(e)","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"Bath Exponent with types = \"fA\", operator size = (2, 2), η = 0.0 + 3.4090909090909113e-6im, γ = 0.1732050807568877 - 0.005im.","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"One can even obtain the Exponent with iterative method:","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"for e in bath\n    println(e)\nend","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"Bath Exponent with types = \"fA\", operator size = (2, 2), η = 6.25e-6 - 3.4090909090909113e-6im, γ = 0.05 - 0.005im.\n\nBath Exponent with types = \"fA\", operator size = (2, 2), η = 0.0 + 3.4090909090909113e-6im, γ = 0.1732050807568877 - 0.005im.\n\nBath Exponent with types = \"fE\", operator size = (2, 2), η = 6.25e-6 - 3.4090909090909113e-6im, γ = 0.05 + 0.005im.\n\nBath Exponent with types = \"fE\", operator size = (2, 2), η = 0.0 + 3.4090909090909113e-6im, γ = 0.1732050807568877 + 0.005im.","category":"page"},{"location":"fermionic_bath/#Types-of-Exponent","page":"Fermionic Bath","title":"Types of Exponent","text":"","category":"section"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"The different types of the (fermionic-bath) Exponent:","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"\"fA\" : from absorption fermionic correlation function C^nu=+(t_1 t_2)\n\"fE\" : from emission fermionic correlation function C^nu=-(t_1 t_2)","category":"page"},{"location":"fermionic_bath/#doc-Fermion-Lorentz","page":"Fermionic Bath","title":"Lorentz Spectral Density","text":"","category":"section"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"J(omega)=fracGamma W^2(omega-mu)^2+W^2","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"Here, Gamma represents the coupling strength between system and the fermionic environment with chemical potential mu and band-width W.","category":"page"},{"location":"fermionic_bath/#Matsubara-Expansion","page":"Fermionic Bath","title":"Matsubara Expansion","text":"","category":"section"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"With Matsubara Expansion, the correlation function can be analytically solved and expressed as follows:","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"C^nu(t_1 t_2)=sum_l=1^infty eta_l^nu exp(-gamma_l^nu (t_1-t_2))","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"with","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"beginaligned\ngamma_1^nu = W-nu i mu\neta_1^nu = fracGamma W2 fleft(fraciWk_B Tright)\ngamma_lneq 1^nu = zeta_l k_B T - nu i mu\neta_lneq 1^nu = -i k_B T cdot fracGamma W^2-(zeta_l k_B T)^2+W^2\nf(x) = exp(x) + 1^-1\nendaligned","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"where zeta_l=(2 l - 1)pi. This can be constructed by the built-in function Fermion_Lorentz_Matsubara:","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"ds # coupling operator\nΓ  # coupling strength\nμ  # chemical potential of the environment\nW  # band-width  of the environment\nT  # temperature of the environment\nN  # Number of exponential terms for each correlation functions (C^{+} and C^{-})\nbath = Fermion_Lorentz_Matsubara(ds, Γ, μ, W, T, N - 1)","category":"page"},{"location":"fermionic_bath/#Padé-Expansion","page":"Fermionic Bath","title":"Padé Expansion","text":"","category":"section"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"With Padé Expansion, the correlation function can be analytically solved and expressed as the following exponential terms:","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"C^nu(t_1 t_2)=sum_l=1^infty eta_l^nu exp(-gamma_l^nu (t_1-t_2))","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"with","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"beginaligned\ngamma_1^nu = W-nu i mu\neta_1^nu = fracGamma W2 fleft(fraciWk_B Tright)\ngamma_lneq 1^nu = zeta_l k_B T - nu i mu\neta_lneq 1^nu = -i kappa_l k_B T cdot fracGamma W^2-(zeta_l k_B T)^2+W^2\nf(x) = frac12-sum_l=2^N frac2kappa_l xx^2+zeta_l^2\nendaligned","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"where the parameters kappa_l and zeta_l are described in J. Chem. Phys. 134, 244106 (2011) and N represents the number of exponential terms for C^nu=pm. This can be constructed by the built-in function Fermion_Lorentz_Pade:","category":"page"},{"location":"fermionic_bath/","page":"Fermionic Bath","title":"Fermionic Bath","text":"ds # coupling operator\nΓ  # coupling strength\nμ  # chemical potential of the environment\nW  # band-width  of the environment\nT  # temperature of the environment\nN  # Number of exponential terms for each correlation functions (C^{+} and C^{-})\nbath = Fermion_Lorentz_Pade(ds, Γ, μ, W, T, N - 1)","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#HierarchicalEOM.jl","page":"Installation","title":"HierarchicalEOM.jl","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To install HierarchicalEOM.jl, run the following commands inside Julia's interactive session (also known as REPL):","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"HierarchicalEOM\")","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Alternatively, this can also be done in Julia's Pkg REPL by pressing the key ] in the REPL to use the package mode, and then type the following command:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(1.8) pkg> add HierarchicalEOM","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"More information about Julia's package manager can be found at Pkg.jl.  ","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"note: Julia 1.8\nHierarchicalEOM.jl requires Julia 1.8 or higher","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"To load the package and check the version information, use the command:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using HierarchicalEOM\njulia> HierarchicalEOM.versioninfo()","category":"page"},{"location":"install/#Other-Useful-Packages","page":"Installation","title":"Other Useful Packages","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"In order to get a better experience and take full advantage of HierarchicalEOM, we recommend to install the following external packages:","category":"page"},{"location":"install/#[QuantumOptics.jl](https://qojulia.org/)","page":"Installation","title":"QuantumOptics.jl","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"QuantumOptics framework provides many useful functions to create arbitrary quantum states and operators which can be combined in all the expected ways. Constructing arbitrary Hamiltonians and specifying initial states is also straightforward.  ","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"note: Note\nThe inputs in HierarchicalEOM should be child-type of the standard Base.AbstractVector (for vector-type quantum states) and Base.AbstractMatrix (for matrix-type quantum operators). Users can still construct the vectors or matrices by standard method and take it as the input of HierarchicalEOM.   For the users who constructs the quantum objects by QuantumOptics package, the standard type of vectors or matrices are stored in the .data field of the objects, i.e., op.data (where op is a QuantumOptics-type object). Thus, users should take it as the inputs of HierarchicalEOM for objects in QuantumOptics package.","category":"page"},{"location":"install/#[DifferentialEquations.jl](https://diffeq.sciml.ai/stable/)","page":"Installation","title":"DifferentialEquations.jl","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"DifferentialEquations is needed to provide the low-level ODE solvers especially for solving time evolution. For low dependency usage, users can use OrdinaryDiffEq.jl instead.","category":"page"},{"location":"install/#[LinearSolve.jl](http://linearsolve.sciml.ai/stable/)","page":"Installation","title":"LinearSolve.jl","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"LinearSolve is a unified interface for the linear solving packages of Julia. It interfaces with other packages of the Julia ecosystem to make it easier to test alternative solver packages and pass small types to control algorithm swapping. It is needed to provide the solvers especially for solving SteadyState and spectrum for both bosonic and fermionic systems.","category":"page"},{"location":"install/#[JLD2.jl](https://juliaio.github.io/JLD2.jl/stable/)","page":"Installation","title":"JLD2.jl","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"JLD2 saves and loads Julia data structures in a format comprising a subset of HDF5. Because the size of matrix in HierarchicalEOM is usually super large and leads to long time calculation, we support the functionality for saving and loading the HierarchicalEOM-type objects into files by JLD2 >= 0.4.23.","category":"page"},{"location":"install/#[PyPlot.jl](https://github.com/JuliaPy/PyPlot.jl)","page":"Installation","title":"PyPlot.jl","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"PyPlot.jl provides a Julia interface to the Matplotlib plotting library from Python, and specifically to the matplotlib.pyplot module.","category":"page"},{"location":"heom_matrix/M_Boson/#doc-M_Boson","page":"HEOMLS for Bosonic Bath","title":"HEOMLS Matrix for Bosonic Baths","text":"","category":"section"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"The HEOM Liouvillian superoperator matrix struct M_Boson <: AbstractHEOMMatrix which describes the interactions between the system and multiple Bosonic baths.","category":"page"},{"location":"heom_matrix/M_Boson/#Construct-Matrix","page":"HEOMLS for Bosonic Bath","title":"Construct Matrix","text":"","category":"section"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"To construct the HEOM matrix in this case, one can call ","category":"page"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"M_Boson(Hsys, tier, Bath, parity) with the following parameters:","category":"page"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"args (Arguments)","category":"page"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"Hsys : The time-independent system Hamiltonian\ntier::Int : the tier (cutoff level) for the bosonic bath\nBath::Vector{BosonBath} : objects for different bosonic baths\nparity::Symbol : the parity label of the fermionic system. Defaults to :even.","category":"page"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"kwargs (Keyword Arguments)","category":"page"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"threshold::Real : The threshold of the importance value. Defaults to 0.0.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.","category":"page"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"For example:","category":"page"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"Hs::AbstractMatrix # system Hamiltonian\ntier = 3\nBath::BosonBath\n\n# create HEOMLS matrix in both :even and :odd parity\nM_even = M_Boson(Hs, tier, Bath) \nM_odd  = M_Boson(Hs, tier, Bath, :odd) ","category":"page"},{"location":"heom_matrix/M_Boson/#Fields","page":"HEOMLS for Bosonic Bath","title":"Fields","text":"","category":"section"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"The fields of the structure M_Boson are as follows:","category":"page"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"data : the sparse matrix of HEOM Liouvillian superoperator\ntier : the tier (cutoff level) for the bosonic hierarchy\ndim : the dimension of system\nN : the number of total ADOs\nsup_dim : the dimension of system superoperator\nparity : the parity label of the fermionic system.\nbath::Vector{BosonBath} : the vector which stores all BosonBath objects\nhierarchy::HierarchyDict: the object which contains all dictionaries for boson-bath-ADOs hierarchy.","category":"page"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"One obtain the value of each fields as follows:","category":"page"},{"location":"heom_matrix/M_Boson/","page":"HEOMLS for Bosonic Bath","title":"HEOMLS for Bosonic Bath","text":"M::M_Boson\n\nM.data\nM.tier\nM.dim\nM.N\nM.sup_dim\nM.parity\nM.bath\nM.hierarchy","category":"page"},{"location":"heom_matrix/intro/#doc-HEOMLS-Matrix","page":"Introduction","title":"Hierarchical Equations of Motion Liouvillian Superoperator (HEOMLS) Matrix","text":"","category":"section"},{"location":"heom_matrix/intro/#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"The hierarchical equations of motion Liouvillian superoperator (HEOMLS) hatmathcalM characterizes the dynamics in the full auxiliary density operators (ADOs) space, namely ","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"partial_trho^(mnp)_textbfj vert textbfq(t)=hatmathcalMrho^(mnp)_textbfj vert textbfq(t)","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"and it can, numerically, be expressed as a matrix. ","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"In HierarchicalEOM.jl, all different types of HEOMLS hatmathcalM are subtype of AbstractHEOMMatrix.","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"The HEOMLS hatmathcalM not only characterizes the bare system dynamics (based on system Hamiltonian), but it also encodes the system-and-multiple-bosonic-baths and system-and-multiple-fermionic-baths interactions based on Bosonic Bath and Fermionic Bath, respectively. For a specific mth-level-bosonic-and-nth-level-fermionic auxiliary density operator rho^(mnp)_textbfj vert textbfq, it will be coupled to the following ADOs through hatmathcalM:","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"(m+1)th-level-bosonic-and-nth-level-fermionic ADOs\n(m-1)th-level-bosonic-and-nth-level-fermionic ADOs\nmth-level-bosonic-and-(n+1)th-level-fermionic ADOs\nmth-level-bosonic-and-(n-1)th-level-fermionic ADOs","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"and thus forms the two-fold hierarchy relations. See our paper for more details.","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"In practice, the size of the matrix hatmathcalM must be finite and the hierarchical equations must be truncated at a suitable bosonic-level (m_textrmmax) and fermionic-level (n_textrmmax). These truncation levels (tiers) must be given when constructing hatmathcalM.","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"Hs::AbstractMatrix  # system Hamiltonian\nBbath::BosonBath    # bosonic   bath object\nFbath::FermionBath  # fermionic bath object\nBtier::Int          # bosonic   truncation level \nFtier::Int          # fermionic truncation level \n\nM = M_Boson(Hs, Btier, Bbath)\nM = M_Fermion(Hs, Ftier, Fbath)\nM = M_Boson_Fermion(Hs, Btier, Ftier, Bbath, Fbath)","category":"page"},{"location":"heom_matrix/intro/#doc-Importance-Value-and-Threshold","page":"Introduction","title":"Importance Value and Threshold","text":"","category":"section"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"The main computational complexity can be quantified by the total number of auxiliary density operators (ADOs) because it directly affects the size of hatmathcalM. ","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"The computational effort can be further optimized by associating an importance value mathcalI to each ADO and then discarding all the ADOs (in the second and higher levels) whose importance value is smaller than a threshold value mathcalI_textrmth. The importance value for a given ADO : mathcalIleft(rho^(mnp)_textbfj vert textbfqright) is determined by its corresponding exponential terms of bath correlation function [see Phys. Rev. B 88, 235426 (2013) and Phys. Rev. B 103, 235413 (2021)]. This allows us to only consider the ADOs which affects the dynamics more, and thus, reduce the size of hatmathcalM. Also see our paper for more details.","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"When you specify a threshold value mathcalI_textrmth with the parameter threshold to construct hatmathcalM, we will remain all the ADOs where their hierarchy levels (mn)in(00) (01) (10) (11), and all the other high-level ADOs may be neglected if mathcalIleft(rho^(mnp)_textbfj vert textbfqright)  mathcalI_textrmth. ","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"Hs::AbstractMatrix  # system Hamiltonian\nBbath::BosonBath    # bosonic   bath object\nFbath::FermionBath  # fermionic bath object\nBtier::Int          # bosonic   truncation level \nFtier::Int          # fermionic truncation level \n\nM = M_Boson(Hs, Btier, Bbath; threshold=1e-7)\nM = M_Fermion(Hs, Ftier, Fbath; threshold=1e-7)\nM = M_Boson_Fermion(Hs, Btier, Ftier, Bbath, Fbath; threshold=1e-7)","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"note: Default value of importance threshold\nThe full hierarchical equations can be recovered in the limiting case mathcalI_textrmthrightarrow 0, which is the default value of the parameter : threshold=0.0. This means that all of the ADOs will be taken into account by default.","category":"page"},{"location":"heom_matrix/intro/#doc-Parity","page":"Introduction","title":"Parity Support for HEOMLS Matrices","text":"","category":"section"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"When the system Hamiltonian contains fermionic systems, the HEOMLS matrix hatmathcalM might be constructed into a different one depend on the parity of the operator it is acting on. Usually, it is acting on the reduced density operator and auxiliary density operators (ADOs), which are all in :even-parity. However, there are some situations (for example, calculating spectrum for fermionic systems) where hatmathcalM is acting on operators with :odd-parity.","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"One can specify the parameter parity::Symbol in the function of constructing hatmathcalM to be :even or :odd. The default value of the parameter is parity=:even.","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"Hs::AbstractMatrix  # system Hamiltonian\nBbath::BosonBath    # bosonic   bath object\nFbath::FermionBath  # fermionic bath object\nBtier::Int          # bosonic   truncation level \nFtier::Int          # fermionic truncation level \n\n# create HEOMLS matrix in :even or :odd parity\nM_even = M_S(Hs, :even)\nM_odd  = M_S(Hs, :odd)\n\nM_even = M_Boson(Hs, Btier, Bbath, :even) \nM_odd  = M_Boson(Hs, Btier, Bbath, :odd) \n\nM_even = M_Fermion(Hs, Ftier, Fbath, :even) \nM_odd  = M_Fermion(Hs, Ftier, Fbath, :odd)\n\nM_even = M_Boson_Fermion(Hs, Btier, Ftier, Bbath, Fbath, :even) \nM_odd  = M_Boson_Fermion(Hs, Btier, Ftier, Bbath, Fbath, :odd) ","category":"page"},{"location":"heom_matrix/intro/#Methods","page":"Introduction","title":"Methods","text":"","category":"section"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"All of the HEOMLS matrices supports the following two Base Functions :","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"size(M::AbstractHEOMMatrix) : Returns the size of the HEOMLS matrix.\nBracket operator [i,j] : Returns the (i, j)-element(s) in the HEOMLS matrix.","category":"page"},{"location":"heom_matrix/intro/","page":"Introduction","title":"Introduction","text":"M::AbstractHEOMMatrix\n\nm, n = size(M)\nM[10, 12]\nM[2:4, 2:4]\nM[1,:]\nM[:,2]","category":"page"},{"location":"time_evolution/#doc-Time-Evolution","page":"Time Evolution","title":"Time Evolution","text":"","category":"section"},{"location":"time_evolution/#Introduction","page":"Time Evolution","title":"Introduction","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"HierarchicalEOM.jl implements various methods and solvers to simulate the open quantum system dynamics.  The HEOM Liouvillian superoperator (HEOMLS) matrix hatmathcalM characterizes the dynamics of the reduce state and in the full extended space of all auxiliary density operators (ADOs) rho^(mnp)_textbfj vert textbfq(t), namely","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"beginequation\npartial_trho^(mnp)_textbfj vert textbfq(t)=hatmathcalMrho^(mnp)_textbfj vert textbfq(t)\nendequation","category":"page"},{"location":"time_evolution/#Output-of-evolution","page":"Time Evolution","title":"Output of evolution","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"To solve the dynamics of the reduced state and also all the ADOs, you only need to call evolution. Different methods are implemented with different input parameters of the function which makes it easy to switch between different methods. The output of the function evolution for each methods will always be in the type Vector{ADOs}, which contains a list of ADOs corresponds to the given time steps.","category":"page"},{"location":"time_evolution/#Expectation-Values","page":"Time Evolution","title":"Expectation Values","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"Given an observable A and the ADOs rho^(mnp)_textbfj vert textbfq(t), one can calculate the expectation value by","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"langle A(t) rangle = textrmTrleftA rho^(00p)_ vert (t)right","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"where, m=n=0 represents the reduced density operator, see ADOs for more details.","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"One can directly calculate the expectation values using the function Expect together with the output of evolution:","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"A::AbstractMatrix # observable\nados_list = evolution(...) # the input parameters depend on the different methods you choose.\n\nElist = Expect(A, ados_list)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"Here, Elist contains the expectation values corresponding to the ados_list (i.e., the reduced density operator in each time step).","category":"page"},{"location":"time_evolution/#Common-and-optional-parameters-for-evolution","page":"Time Evolution","title":"Common and optional parameters for evolution","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"Furthermore, there are two common optional parameters for all the methods provided below:","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"verbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nfilename::String : If filename was specified, the ADOs at each time point will be saved into the JLD2 file during the solving process. Default to Empty String: \"\".","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"If the filename is specified, the function will automatically save (update) the ADOs to the file (with \".jld2\" behind the filename) once it obtains the solution of the specified time step. The saving method is based on the package JLD2.jl, which saves and loads Julia data structures in a format comprising a subset of HDF5.","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"tlist = 0:0.5:5\nados_list = evolution(..., tlist, ...; filename=\"test\", ...)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"The solution of the ADOs for each time step in tlist is saved in the file named \"test.jld2\".","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"To retrieve the solution (ADOs) from a previously saved file \"text.jld2\", just read the file with the methods provided by JLD2.jl. The solution for a specific time step can be extract by using the string of the time step as the \"key\". For example, if you want to obtain the solution at time 1.5, which is one of the time steps in tlist:","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"using HierarchicalEOM, JLD2 # rembember to import these before retrieving the solution\n\nt = 1.5\nfilename = \"test.jld2\"\njldopen(filename, \"r\") do file\n    ados = file[string(t)]\nend","category":"page"},{"location":"time_evolution/#Ordinary-Differential-Equation-Method","page":"Time Evolution","title":"Ordinary Differential Equation Method","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"The first method is implemented by solving the ordinary differential equation (ODE) as shown above. HierarchicalEOM.jl wraps some of the functions in DifferentialEquations.jl, which is a very rich numerical library for solving the differential equations and provides many ODE solvers. It offers quite a few options for the user to tailor the solver to their specific needs. The default solver (and its corresponding settings) are chosen to suit commonly encountered problems and should work fine for most of the cases. If you require more specialized methods, such as the choice of algorithm, please refer to benchmarks for DifferentialEquations solvers and also the documentation of DifferentialEquations.jl.","category":"page"},{"location":"time_evolution/#Given-the-initial-state-as-Density-Operator-(AbstractMatrix-type)","page":"Time Evolution","title":"Given the initial state as Density Operator (AbstractMatrix type)","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"See the docstring of this method:  ","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"evolution(M::AbstractHEOMMatrix, ρ0, tlist::AbstractVector)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"# the time-independent HEOMLS matrix\nM::AbstractHEOMMatrix  \n\n# the initial state of the system density operator\nρ0::AbstractMatrix\n\n# specific time points to save the solution during the solving process.  \ntlist = 0:0.5:2 # [0.0, 0.5, 1.0, 1.5, 2.0]\n\nados_list = evolution(M, ρ0, tlist)","category":"page"},{"location":"time_evolution/#Given-the-initial-state-as-Auxiliary-Density-Operators","page":"Time Evolution","title":"Given the initial state as Auxiliary Density Operators","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"note: Note\nThis method is usually used when you want to solve the time evolution again with the initial state are given from the last time point of the previous result.","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"See the docstring of this method:   ","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"evolution(M::AbstractHEOMMatrix, ados::ADOs, tlist::AbstractVector)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"# the time-independent HEOMLS matrix\nM::AbstractHEOMMatrix  \n\n# the initial state of the ADOs (usually obtianed from previous solving result)\nados::ADOs      \n\n# specific time points to save the solution during the solving process. \ntlist = 0:0.5:2 # [0.0, 0.5, 1.0, 1.5, 2.0]\n\nados_list = evolution(M, ados, tlist)","category":"page"},{"location":"time_evolution/#Propagator-Method","page":"Time Evolution","title":"Propagator Method","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"The second method is implemented by directly construct the propagator of a given HEOMLS matrix hatmathcalM. Because hatmathcalM is time-independent, the equation above can be solved analytically as","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"rho^(mnp)_textbfj vert textbfq(t)=hatmathcalG(t)rho^(mnp)_textbfj vert textbfq(0)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"where hatmathcalG(t)equiv exp(hatmathcalMt) is the propagator for all ADOs corresponding to hatmathcalM.","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"To construct the propagator, we wrap the function in the package fastExpm.jl, which is optimized for the exponentiation of either large-dense or sparse matrices.","category":"page"},{"location":"time_evolution/#Given-the-initial-state-as-Density-Operator-(AbstractMatrix-type)-2","page":"Time Evolution","title":"Given the initial state as Density Operator (AbstractMatrix type)","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"See the docstring of this method:  ","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"evolution(M::AbstractHEOMMatrix, ρ0, Δt::Real, steps::Int)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"# the time-independent HEOMLS matrix\nM::AbstractHEOMMatrix  \n\n# the initial state of the system density operator\nρ0::AbstractMatrix\n\n# A specific time interval (time step)\nΔt = 0.5\n\n# The number of time steps for the propagator to apply\nsteps = 4\n\n# equivalent to tlist = 0 : Δt : (Δt * steps)\nados_list = evolution(M, ρ0, Δt, steps) ","category":"page"},{"location":"time_evolution/#Given-the-initial-state-as-Auxiliary-Density-Operators-2","page":"Time Evolution","title":"Given the initial state as Auxiliary Density Operators","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"note: Note\nThis method is usually used when you want to solve the time evolution again with the initial state are given from the last time point of the previous result.","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"See the docstring of this method:  ","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"evolution(M::AbstractHEOMMatrix, ados::ADOs, Δt::Real, steps::Int)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"# the time-independent HEOMLS matrix\nM::AbstractHEOMMatrix  \n\n# the initial state of the ADOs (usually obtianed from previous solving result)\nados::ADOs\n\n# A specific time interval (time step)\nΔt = 0.5\n\n# The number of time steps for the propagator to apply\nsteps = 4\n\n# equivalent to tlist = 0 : Δt : (Δt * steps)\nados_list = evolution(M, ados, Δt, steps) ","category":"page"},{"location":"time_evolution/#Time-Dependent-Problems","page":"Time Evolution","title":"Time Dependent Problems","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"In general, the time-dependent system Hamiltonian can be separated into the time-independent and time-dependent parts, namely","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"H_s (t) = H_0 + H_1(t)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"We again wrap some of the functions in DifferentialEquations.jl to solve the time-dependent problems here.","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"To deal with the time-dependent system Hamiltonian problem in HierarchicalEOM.jl, we first construct the HEOMLS matrices hatmathcalM with time-independent Hamiltonian H_0:","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"M = M_S(H0, ...)\nM = M_Boson(H0, ...)\nM = M_Fermion(H0, ...)\nM = M_BosonFermion(H0, ...)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"To solve the dynamics characterized by hatmathcalM together with the time-dependent part of system Hamiltonian H_1(t), you can call either of the following two functions (one takes the type of initial state as density matrix and the other one takes ADOs):","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"evolution(M::AbstractHEOMMatrix, ρ0, tlist::AbstractVector, H::Function, param::Tuple = ())\nevolution(M::AbstractHEOMMatrix, ados::ADOs, tlist::AbstractVector, H::Function, param::Tuple = ()).","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"Here, the definition of user-defined function H must be in the form H(p::Tuple, t) and returns the time-dependent part of system Hamiltonian (in AbstractMatrix type) at any given time point t. The parameter p should be a Tuple which contains all the extra parameters you need for the function H. For example:","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"function H_pump(p, t)  \n    p0, p1, p2 = p \n    # in this case, p should be passed in as a tuple: (p0, p1, p2) \n    \n    σx = [0 1; 1 0] # Pauli-X matrix\n    return (sin(p0 * t) + sin(p1 * t) + sin(p2 * t)) * σx\nend","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"The parameter tuple p will be passed to your function H directly from one of the parameter in evolution called param:","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"M::AbstractHEOMMatrix\nρ0::AbstractMatrix\ntlist = 0:0.1:10\np = (0.1, 1, 10)\n\nados_list = evolution(M, ρ0, tlist, H_pump, p)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"warning: Warning\nIf you don't need any extra param in your case, you still need to put a redundant one in the definition of H, for example:","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"function H_pump(p, t)\n    σx = [0 1; 1 0] # Pauli-X matrix\n    return sin(0.1 * t) * σx\nend\n\nM::AbstractHEOMMatrix\nρ0::AbstractMatrix\ntlist = 0:0.1:10\n\nados_list = evolution(M, ρ0, tlist, H_pump)","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"note: Note\nThe default value for param in evolution is an empty tuple ().","category":"page"},{"location":"time_evolution/#Given-the-initial-state-as-Density-Operator-(AbstractMatrix-type)-3","page":"Time Evolution","title":"Given the initial state as Density Operator (AbstractMatrix type)","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"See the docstring of this method:  ","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"evolution(M::AbstractHEOMMatrix, ρ0, tlist::AbstractVector, H::Function, param::Tuple = ())","category":"page"},{"location":"time_evolution/#Given-the-initial-state-as-Auxiliary-Density-Operators-3","page":"Time Evolution","title":"Given the initial state as Auxiliary Density Operators","text":"","category":"section"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"note: Note\nThis method is usually used when you want to solve the time evolution again with the initial state are given from the last time point of the previous result.","category":"page"},{"location":"time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"See the docstring of this method:   evolution(M::AbstractHEOMMatrix, ados::ADOs, tlist::AbstractVector, H::Function, param::Tuple = ())","category":"page"},{"location":"heom_matrix/M_Fermion/#doc-M_Fermion","page":"HEOMLS for Fermionic Bath","title":"HEOMLS Matrix for Fermionic Baths","text":"","category":"section"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"The HEOM Liouvillian superoperator matrix struct M_Fermion <: AbstractHEOMMatrix which describes the interactions between the system and multiple Fermionic baths.","category":"page"},{"location":"heom_matrix/M_Fermion/#Construct-Matrix","page":"HEOMLS for Fermionic Bath","title":"Construct Matrix","text":"","category":"section"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"To construct the HEOM matrix in this case, one can call ","category":"page"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"M_Fermion(Hsys, tier, Bath, parity) with the following parameters:","category":"page"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"args (Arguments)","category":"page"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"Hsys : The time-independent system Hamiltonian\ntier::Int : the tier (cutoff level) for the fermionic bath\nBath::Vector{FermionBath} : objects for different fermionic baths\nparity::Symbol : the parity label of the fermionic system. Defaults to :even.","category":"page"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"kwargs (Keyword Arguments)","category":"page"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"threshold::Real : The threshold of the importance value. Defaults to 0.0.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.","category":"page"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"For example:","category":"page"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"Hs::AbstractMatrix # system Hamiltonian\ntier = 3\nBath::FermionBath\n\n# create HEOMLS matrix in both :even and :odd parity\nM_even = M_Fermion(Hs, tier, Bath) \nM_odd  = M_Fermion(Hs, tier, Bath, :odd) ","category":"page"},{"location":"heom_matrix/M_Fermion/#Fields","page":"HEOMLS for Fermionic Bath","title":"Fields","text":"","category":"section"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"The fields of the structure M_Fermion are as follows:","category":"page"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"data : the sparse matrix of HEOM Liouvillian superoperator\ntier : the tier (cutoff level) for the fermionic hierarchy\ndim : the dimension of system\nN : the number of total ADOs\nsup_dim : the dimension of system superoperator\nparity : the parity label of the fermionic system.\nbath::Vector{FermionBath} : the vector which stores all FermionBath objects\nhierarchy::HierarchyDict: the object which contains all dictionaries for fermion-bath-ADOs hierarchy.","category":"page"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"One obtain the value of each fields as follows:","category":"page"},{"location":"heom_matrix/M_Fermion/","page":"HEOMLS for Fermionic Bath","title":"HEOMLS for Fermionic Bath","text":"M::M_Fermion\n\nM.data\nM.tier\nM.dim\nM.N\nM.sup_dim\nM.parity\nM.bath\nM.hierarchy","category":"page"},{"location":"libraryAPI/#Library-API","page":"Library API","title":"Library API","text":"","category":"section"},{"location":"libraryAPI/#Contents","page":"Library API","title":"Contents","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"Pages = [\"libraryAPI.md\"]","category":"page"},{"location":"libraryAPI/#Index","page":"Library API","title":"Index","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"Pages = [\"libraryAPI.md\"]","category":"page"},{"location":"libraryAPI/#lib-Bath","page":"Library API","title":"Bath Module","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"C(bath::BosonBath, tlist::AbstractVector)\nC(bath::FermionBath, tlist::AbstractVector)\nExponent\nBosonBath\nBosonBath(op::AbstractMatrix, η::Vector{Ti}, γ::Vector{Tj}, δ::Number=0.0; combine::Bool=true) where {Ti, Tj <: Number}\nBosonBath(op::AbstractMatrix, η_real::Vector{Ti}, γ_real::Vector{Tj}, η_imag::Vector{Tk}, γ_imag::Vector{Tl}, δ::Tm=0.0; combine::Bool=true) where {Ti, Tj, Tk, Tl, Tm <: Number}\nbosonReal\nbosonReal(op::AbstractMatrix, η_real::Vector{Ti}, γ_real::Vector{Tj}) where {Ti, Tj <: Number}\nbosonImag\nbosonImag(op::AbstractMatrix, η_real::Vector{Ti}, γ_real::Vector{Tj}) where {Ti, Tj <: Number}\nbosonRealImag\nbosonRealImag(op::AbstractMatrix, η_real::Vector{Ti}, η_imag::Vector{Tj}, γ::Vector{Tk}) where {Ti, Tj, Tk <: Number}\nFermionBath\nFermionBath(op::AbstractMatrix, η_absorb::Vector{Ti}, γ_absorb::Vector{Tj}, η_emit::Vector{Tk}, γ_emit::Vector{Tl}, δ::Tm=0.0) where {Ti, Tj, Tk, Tl, Tm <: Number}\nfermionAbsorb\nfermionAbsorb(op::AbstractMatrix, η_absorb::Vector{Ti}, γ_absorb::Vector{Tj}, η_emit::Vector{Tk}) where {Ti, Tj, Tk <: Number}\nfermionEmit\nfermionEmit(op::AbstractMatrix, η_emit::Vector{Ti}, γ_emit::Vector{Tj}, η_absorb::Vector{Tk}) where {Ti, Tj, Tk <: Number}","category":"page"},{"location":"libraryAPI/#HierarchicalEOM.Bath.C-Tuple{BosonBath, AbstractVector}","page":"Library API","title":"HierarchicalEOM.Bath.C","text":"C(bath, tlist)\n\nCalculate the correlation function C(t) for a given bosonic bath and time list.\n\nNote that\n\nC(t)=sum_u=textrmRtextrmI(delta_u textrmR + idelta_u textrmI)C^u(t)\n\nParameters\n\nbath::BosonBath : The bath object which describes a certain bosonic bath.\ntlist::AbstractVector: The specific time.\n\nReturns\n\nclist::Vector{ComplexF64} : a list of the value of correlation function according to the given time list.\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.Bath.C-Tuple{FermionBath, AbstractVector}","page":"Library API","title":"HierarchicalEOM.Bath.C","text":"C(bath, tlist)\n\nCalculate the correlation function C^nu=+(t) and C^nu=-(t) for a given fermionic bath and time list. Here, nu=+ represents the absorption process and nu=- represents the emmision process.\n\nParameters\n\nbath::FermionBath : The bath object which describes a certain fermionic bath.\ntlist::AbstractVector: The specific time.\n\nReturns\n\ncplist::Vector{ComplexF64} : a list of the value of the absorption (nu=+) correlation function according to the given time list.\ncmlist::Vector{ComplexF64} : a list of the value of the emission (nu=-) correlation function according to the given time list.\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.Bath.Exponent","page":"Library API","title":"HierarchicalEOM.Bath.Exponent","text":"struct Exponent\n\nAn object which describes a single exponential-expansion term (naively, an excitation mode) within the decomposition of the bath correlation functions.\n\nThe expansion of a bath correlation function can be expressed as : C(t) = sum_i eta_i exp(-gamma_i t).\n\nFields\n\nop : The system coupling operator according to system-bath interaction.\nη::Number : the coefficient eta_i in bath correlation function.\nγ::Number : the coefficient gamma_i in bath correlation function.\ntypes::String : The type-tag of the exponent.\n\nThe different types of the Exponent:\n\n\"bR\" : from real part of bosonic correlation function C^u=textrmR(t)\n\"bI\" : from imaginary part of bosonic correlation function C^u=textrmI(t)\n\"bRI\" : from combined (real and imaginary part) bosonic bath correlation function C(t)\n\"fA\" : from absorption fermionic correlation function C^nu=+(t)\n\"fE\" : from emission fermionic correlation function C^nu=-(t)\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.Bath.BosonBath","page":"Library API","title":"HierarchicalEOM.Bath.BosonBath","text":"struct BosonBath <: AbstractBath\n\nAn object which describes the interaction between system and bosonic bath\n\nFields\n\nbath : the different boson-bath-type objects which describes the interaction between system and bosonic bath\nop : The system coupling operator, must be Hermitian and, for fermionic systems, even-parity to be compatible with charge conservation.\ndim : the dimension of the coupling operator (should be equal to the system dimension).\nNterm : the number of exponential-expansion term of correlation functions\nδ : The approximation discrepancy which is used for adding the terminator to HEOM matrix (see function: addTerminator)\n\nMethods\n\nOne can obtain the k-th exponent (exponential-expansion term) from bath::BosonBath by calling : bath[k]. HierarchicalEOM.jl also supports the following calls (methods) :\n\nbath[1:k];   # returns a vector which contains the exponents from the `1`-st to the `k`-th term.\nbath[1:end]; # returns a vector which contains all the exponential-expansion terms\nbath[:];     # returns a vector which contains all the exponential-expansion terms\nfrom b in bath\n    # do something\nend\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.Bath.BosonBath-Union{Tuple{Tj}, Tuple{Ti}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}, Number}} where {Ti, Tj<:Number}","page":"Library API","title":"HierarchicalEOM.Bath.BosonBath","text":"BosonBath(op, η, γ, δ=0.0; combine=true)\n\nGenerate BosonBath object for the case where real part and imaginary part of the correlation function are combined.\n\nbeginaligned\nC(tau)\n=frac12piint_0^infty domega J(omega)leftn(omega)e^iomega tau+(n(omega)+1)e^-iomega tauright\n=sum_i eta_i exp(-gamma_i tau)\nendaligned\n\nwhere J(omega) is the spectral density of the bath and n(omega) represents the Bose-Einstein distribution.\n\nParameters\n\nop : The system coupling operator, must be Hermitian and, for fermionic systems, even-parity to be compatible with charge conservation.\nη::Vector{Ti<:Number} : the coefficients eta_i in bath correlation function C(tau).\nγ::Vector{Tj<:Number} : the coefficients gamma_i in bath correlation function C(tau).\nδ::Number : The approximation discrepancy (Default to 0.0) which is used for adding the terminator to HEOM matrix (see function: addTerminator)\ncombine::Bool : Whether to combine the exponential-expansion terms with the same frequency. Defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.Bath.BosonBath-Union{Tuple{Tm}, Tuple{Tl}, Tuple{Tk}, Tuple{Tj}, Tuple{Ti}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}, Vector{Tk}, Vector{Tl}}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}, Vector{Tk}, Vector{Tl}, Tm}} where {Ti, Tj, Tk, Tl, Tm<:Number}","page":"Library API","title":"HierarchicalEOM.Bath.BosonBath","text":"BosonBath(op, η_real, γ_real, η_imag, γ_imag, δ=0.0; combine=true)\n\nGenerate BosonBath object for the case where the correlation function splits into real part and imaginary part.\n\nbeginaligned\nC(tau)\n=frac12piint_0^infty domega J(omega)leftn(omega)e^iomega tau+(n(omega)+1)e^-iomega tauright\n=sum_i eta_i exp(-gamma_i tau)\nendaligned\n\nwhere J(omega) is the spectral density of the bath and n(omega) represents the Bose-Einstein distribution.\n\nWhen gamma_i neq gamma_i^*, a closed form for the HEOM can be obtained by further decomposing C(tau) into its real (R) and imaginary (I) parts as\n\nC(tau)=sum_u=textrmRtextrmI(delta_u textrmR + idelta_u textrmI)C^u(tau)\n\nwhere delta is the Kronecker delta function and C^u(tau)=sum_i eta_i^u exp(-gamma_i^u tau)\n\nParameters\n\nop : The system coupling operator, must be Hermitian and, for fermionic systems, even-parity to be compatible with charge conservation.\nη_real::Vector{Ti<:Number} : the coefficients eta_i in real part of bath correlation function C^u=textrmR.\nγ_real::Vector{Tj<:Number} : the coefficients gamma_i in real part of bath correlation function C^u=textrmR.\nη_imag::Vector{Tk<:Number} : the coefficients eta_i in imaginary part of bath correlation function C^u=textrmI.\nγ_imag::Vector{Tl<:Number} : the coefficients gamma_i in imaginary part of bath correlation function C^u=textrmI.\nδ::Number : The approximation discrepancy (Default to 0.0) which is used for adding the terminator to HEOM matrix (see function: addTerminator)\ncombine::Bool : Whether to combine the exponential-expansion terms with the same frequency. Defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.Bath.bosonReal","page":"Library API","title":"HierarchicalEOM.Bath.bosonReal","text":"struct bosonReal <: AbstractBosonBath\n\nA bosonic bath for the real part of bath correlation function C^u=textrmR\n\nFields\n\nComm  : the super-operator (commutator) for the coupling operator.\ndim : the dimension of the coupling operator (should be equal to the system dimension).\nη : the coefficients eta_i in real part of bath correlation function C^u=textrmR.\nγ : the coefficients gamma_i in real part of bath correlation function C^u=textrmR.\nNterm : the number of exponential-expansion term of correlation function\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.Bath.bosonReal-Union{Tuple{Tj}, Tuple{Ti}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}}} where {Ti, Tj<:Number}","page":"Library API","title":"HierarchicalEOM.Bath.bosonReal","text":"bosonReal(op, η_real, γ_real)\n\nGenerate bosonic bath for the real part of bath correlation function C^u=textrmR\n\nParameters\n\nop : The system coupling operator, must be Hermitian and, for fermionic systems, even-parity to be compatible with charge conservation.\nη_real::Vector{Ti<:Number} : the coefficients eta_i in real part of bath correlation function C^u=textrmR.\nγ_real::Vector{Tj<:Number} : the coefficients gamma_i in real part of bath correlation function C^u=textrmR.\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.Bath.bosonImag","page":"Library API","title":"HierarchicalEOM.Bath.bosonImag","text":"struct bosonImag <: AbstractBosonBath\n\nA bosonic bath for the imaginary part of bath correlation function C^u=textrmI\n\nFields\n\nComm  : the super-operator (commutator) for the coupling operator.\nanComm  : the super-operator (anti-commutator) for the coupling operator.\ndim : the dimension of the coupling operator (should be equal to the system dimension).\nη : the coefficients eta_i in imaginary part of bath correlation function C^u=textrmI.\nγ : the coefficients gamma_i in imaginary part of bath correlation function C^u=textrmI.\nNterm : the number of exponential-expansion term of correlation function\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.Bath.bosonImag-Union{Tuple{Tj}, Tuple{Ti}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}}} where {Ti, Tj<:Number}","page":"Library API","title":"HierarchicalEOM.Bath.bosonImag","text":"bosonImag(op, η_imag, γ_imag)\n\nGenerate bosonic bath for the imaginary part of correlation function C^u=textrmI\n\nParameters\n\nop : The system coupling operator, must be Hermitian and, for fermionic systems, even-parity to be compatible with charge conservation.\nη_imag::Vector{Ti<:Number} : the coefficients eta_i in imaginary part of bath correlation functions C^u=textrmI.\nγ_imag::Vector{Tj<:Number} : the coefficients gamma_i in imaginary part of bath correlation functions C^u=textrmI.\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.Bath.bosonRealImag","page":"Library API","title":"HierarchicalEOM.Bath.bosonRealImag","text":"sturct bosonRealImag <: AbstractBosonBath\n\nA bosonic bath which the real part and imaginary part of the bath correlation function are combined \n\nFields\n\nComm  : the super-operator (commutator) for the coupling operator.\nanComm  : the super-operator (anti-commutator) for the coupling operator.\ndim : the dimension of the coupling operator (should be equal to the system dimension).\nη_real : the real part of coefficients eta_i in bath correlation function sum_i eta_i exp(-gamma_i t).\nη_imag : the imaginary part of coefficients eta_i in bath correlation function sum_i eta_i exp(-gamma_i t).\nγ : the coefficients gamma_i in bath correlation function sum_i eta_i exp(-gamma_i t).\nNterm : the number of exponential-expansion term of correlation function\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.Bath.bosonRealImag-Union{Tuple{Tk}, Tuple{Tj}, Tuple{Ti}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}, Vector{Tk}}} where {Ti, Tj, Tk<:Number}","page":"Library API","title":"HierarchicalEOM.Bath.bosonRealImag","text":"bosonRealImag(op, η_real, η_imag, γ)\n\nGenerate bosonic bath which the real part and imaginary part of the bath correlation function are combined\n\nParameters\n\nop : The system coupling operator, must be Hermitian and, for fermionic systems, even-parity to be compatible with charge conservation.\nη_real::Vector{Ti<:Number} : the real part of coefficients eta_i in bath correlation function sum_i eta_i exp(-gamma_i t).\nη_imag::Vector{Tj<:Number} : the imaginary part of coefficients eta_i in bath correlation function sum_i eta_i exp(-gamma_i t).\nγ::Vector{Tk<:Number} : the coefficients gamma_i in bath correlation function sum_i eta_i exp(-gamma_i t).\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.Bath.FermionBath","page":"Library API","title":"HierarchicalEOM.Bath.FermionBath","text":"struct FermionBath <: AbstractBath\n\nAn object which describes the interaction between system and fermionic bath\n\nFields\n\nbath : the different fermion-bath-type objects which describes the interaction\nop : The system \"emission\" operator according to the system-fermionic-bath interaction.\ndim : the dimension of the coupling operator (should be equal to the system dimension).\nNterm : the number of exponential-expansion term of correlation functions\nδ : The approximation discrepancy which is used for adding the terminator to HEOM matrix (see function: addTerminator)\n\nMethods\n\nOne can obtain the k-th exponent (exponential-expansion term) from bath::FermionBath by calling : bath[k]. HierarchicalEOM.jl also supports the following calls (methods) :\n\nbath[1:k];   # returns a vector which contains the exponents from the `1`-st to the `k`-th term.\nbath[1:end]; # returns a vector which contains all the exponential-expansion terms\nbath[:];     # returns a vector which contains all the exponential-expansion terms\nfrom b in bath\n    # do something\nend\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.Bath.FermionBath-Union{Tuple{Tm}, Tuple{Tl}, Tuple{Tk}, Tuple{Tj}, Tuple{Ti}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}, Vector{Tk}, Vector{Tl}}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}, Vector{Tk}, Vector{Tl}, Tm}} where {Ti, Tj, Tk, Tl, Tm<:Number}","page":"Library API","title":"HierarchicalEOM.Bath.FermionBath","text":"FermionBath(op, η_absorb, γ_absorb, η_emit, γ_emit, δ=0.0)\n\nGenerate FermionBath object\n\nbeginaligned\nC^nu=+(tau)\n=frac12piint_-infty^infty domega J(omega) n(omega) e^iomega tau\n=sum_i eta_i^nu=+ exp(-gamma_i^nu=+ tau)\nC^nu=-(tau)\n=frac12piint_-infty^infty domega J(omega) (1-n(omega)) e^-iomega tau\n=sum_i eta_i^nu=- exp(-gamma_i^nu=- tau)\nendaligned\n\nwhere nu=+ (nu=-) represents absorption (emission) process, J(omega) is the spectral density of the bath and n(omega) is the Fermi-Dirac distribution.\n\nParameters\n\nop : The system annihilation operator according to the system-fermionic-bath interaction.\nη_absorb::Vector{Ti<:Number} : the coefficients eta_i of absorption bath correlation function C^nu=+(tau).\nγ_absorb::Vector{Tj<:Number} : the coefficients gamma_i of absorption bath correlation function C^nu=+(tau).\nη_emit::Vector{Tk<:Number} : the coefficients eta_i of emission bath correlation function C^nu=-(tau).\nγ_emit::Vector{Tl<:Number} : the coefficients gamma_i of emission bath correlation function C^nu=-(tau).\nδ::Number : The approximation discrepancy (Defaults to 0.0) which is used for adding the terminator to HEOM matrix (see function: addTerminator)\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.Bath.fermionAbsorb","page":"Library API","title":"HierarchicalEOM.Bath.fermionAbsorb","text":"struct fermionAbsorb <: AbstractFermionBath\n\nAn bath object which describes the absorption process of the fermionic system by a correlation function C^nu=+\n\nFields\n\nspre   : the super-operator (right side operator multiplication) for the coupling operator.\nspost  : the super-operator (left side operator multiplication) for the coupling operator.\nspreD  : the super-operator (right side operator multiplication) for the adjoint of the coupling operator.\nspostD : the super-operator (left side operator multiplication) for the adjoint of the coupling operator.\ndim : the dimension of the coupling operator (should be equal to the system dimension).\nη : the coefficients eta_i of absorption bath correlation function C^nu=+.\nγ : the coefficients gamma_i of absorption bath correlation function C^nu=+.\nη_emit : the coefficients eta_i of emission bath correlation function C^nu=-.\nNterm : the number of exponential-expansion term of correlation function\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.Bath.fermionAbsorb-Union{Tuple{Tk}, Tuple{Tj}, Tuple{Ti}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}, Vector{Tk}}} where {Ti, Tj, Tk<:Number}","page":"Library API","title":"HierarchicalEOM.Bath.fermionAbsorb","text":"fermionAbsorb(op, η_absorb, γ_absorb, η_emit)\n\nGenerate fermionic bath which describes the absorption process of the fermionic system by a correlation function C^nu=+\n\nParameters\n\nop : The system creation operator according to the system-fermionic-bath interaction.\nη_absorb::Vector{Ti<:Number} : the coefficients eta_i of absorption bath correlation function C^nu=+.\nγ_absorb::Vector{Tj<:Number} : the coefficients gamma_i of absorption bath correlation function C^nu=+.\nη_emit::Vector{Tk<:Number} : the coefficients eta_i of emission bath correlation function C^nu=-.\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.Bath.fermionEmit","page":"Library API","title":"HierarchicalEOM.Bath.fermionEmit","text":"struct fermionEmit <: AbstractFermionBath\n\nAn bath object which describes the emission process of the fermionic system by a correlation function C^nu=-\n\nFields\n\nspre   : the super-operator (right side operator multiplication) for the coupling operator.\nspost  : the super-operator (left side operator multiplication) for the coupling operator.\nspreD  : the super-operator (right side operator multiplication) for the adjoint of the coupling operator.\nspostD : the super-operator (left side operator multiplication) for the adjoint of the coupling operator.\ndim : the dimension of the coupling operator (should be equal to the system dimension).\nη : the coefficients eta_i of emission bath correlation function C^nu=-.\nγ : the coefficients gamma_i of emission bath correlation function C^nu=-.\nη_absorb : the coefficients eta_i of absorption bath correlation function C^nu=+.\nNterm : the number of exponential-expansion term of correlation function\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.Bath.fermionEmit-Union{Tuple{Tk}, Tuple{Tj}, Tuple{Ti}, Tuple{AbstractMatrix, Vector{Ti}, Vector{Tj}, Vector{Tk}}} where {Ti, Tj, Tk<:Number}","page":"Library API","title":"HierarchicalEOM.Bath.fermionEmit","text":"fermionEmit(op, η_emit, γ_emit, η_absorb)\n\nGenerate fermionic bath which describes the emission process of the fermionic system by a correlation function C^nu=-\n\nParameters\n\nop : The system annihilation operator according to the system-fermionic-bath interaction.\nη_emit::Vector{Ti<:Number} : the coefficients eta_i of emission bath correlation function C^nu=-.\nγ_emit::Vector{Ti<:Number} : the coefficients gamma_i of emission bath correlation function C^nu=-.\nη_absorb::Vector{Ti<:Number} : the coefficients eta_i of absorption bath correlation function C^nu=+.\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#Correlation-Functions","page":"Library API","title":"Correlation Functions","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"Boson_DrudeLorentz_Matsubara\nBoson_DrudeLorentz_Pade\nFermion_Lorentz_Matsubara\nFermion_Lorentz_Pade","category":"page"},{"location":"libraryAPI/#HierarchicalEOM.CorrelationFunc.Boson_DrudeLorentz_Matsubara","page":"Library API","title":"HierarchicalEOM.CorrelationFunc.Boson_DrudeLorentz_Matsubara","text":"Boson_DrudeLorentz_Matsubara(op, λ, W, T, N)\n\nConstructing Drude-Lorentz bosonic bath with Matsubara expansion\n\nParameters\n\nop : The system coupling operator, must be Hermitian and, for fermionic systems, even-parity to be compatible with charge conservation.\nλ::Real: The coupling strength between the system and the bath.\nW::Real: The reorganization energy (band-width) of the bath.\nT::Real: The temperature of the bath.\nN::Int: (N+1)-terms of exponential terms are used to approximate the bath correlation function.\n\nReturns\n\nbath::BosonBath : a bosonic bath object with describes the interaction between system and bosonic bath\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#HierarchicalEOM.CorrelationFunc.Boson_DrudeLorentz_Pade","page":"Library API","title":"HierarchicalEOM.CorrelationFunc.Boson_DrudeLorentz_Pade","text":"Boson_DrudeLorentz_Pade(op, λ, W, T, N)\n\nConstructing Drude-Lorentz bosonic bath with Padé expansion\n\nA Padé approximant is a sum-over-poles expansion (see here for more details).\n\nThe application of the Padé method to spectrum decompoisitions is described in Ref. [1].\n\n[1] J. Chem. Phys. 134, 244106 (2011)\n\nParameters\n\nop : The system coupling operator, must be Hermitian and, for fermionic systems, even-parity to be compatible with charge conservation.\nλ::Real: The coupling strength between the system and the bath.\nW::Real: The reorganization energy (band-width) of the bath.\nT::Real: The temperature of the bath.\nN::Int: (N+1)-terms of exponential terms are used to approximate the bath correlation function.\n\nReturns\n\nbath::BosonBath : a bosonic bath object with describes the interaction between system and bosonic bath\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#HierarchicalEOM.CorrelationFunc.Fermion_Lorentz_Matsubara","page":"Library API","title":"HierarchicalEOM.CorrelationFunc.Fermion_Lorentz_Matsubara","text":"Fermion_Lorentz_Matsubara(op, λ, μ, W, T, N)\n\nConstructing Lorentzian fermionic bath with Matsubara expansion\n\nParameters\n\nop : The system annihilation operator according to the system-fermionic-bath interaction.\nλ::Real: The coupling strength between the system and the bath.\nμ::Real: The chemical potential of the bath.\nW::Real: The reorganization energy (band-width) of the bath.\nT::Real: The temperature of the bath.\nN::Int: (N+1)-terms of exponential terms are used to approximate each correlation functions (C^nu=pm).\n\nReturns\n\nbath::FermionBath : a fermionic bath object with describes the interaction between system and fermionic bath\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#HierarchicalEOM.CorrelationFunc.Fermion_Lorentz_Pade","page":"Library API","title":"HierarchicalEOM.CorrelationFunc.Fermion_Lorentz_Pade","text":"Fermion_Lorentz_Pade(op, λ, μ, W, T, N)\n\nConstructing Lorentzian fermionic bath with Padé expansion\n\nA Padé approximant is a sum-over-poles expansion (see here for more details).\n\nThe application of the Padé method to spectrum decompoisitions is described in Ref. [1].\n\n[1] J. Chem. Phys. 134, 244106 (2011)\n\nParameters\n\nop : The system annihilation operator according to the system-fermionic-bath interaction.\nλ::Real: The coupling strength between the system and the bath.\nμ::Real: The chemical potential of the bath.\nW::Real: The reorganization energy (band-width) of the bath.\nT::Real: The temperature of the bath.\nN::Int: (N+1)-terms of exponential terms are used to approximate each correlation functions (C^nu=pm).\n\nReturns\n\nbath::FermionBath : a fermionic bath object with describes the interaction between system and fermionic bath\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#HEOM-Liouvillian-superoperator-matrices","page":"Library API","title":"HEOM Liouvillian superoperator matrices","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"M_S\nM_S(Hsys, parity::Symbol=:even; verbose::Bool=true)\nM_Boson\nM_Boson(Hsys, tier::Int, Bath::Vector{BosonBath}, parity::Symbol=:even; threshold::Real=0.0, verbose::Bool=true)\nM_Fermion\nM_Fermion(Hsys, tier::Int, Bath::Vector{FermionBath}, parity::Symbol=:even; threshold::Real=0.0, verbose::Bool=true)\nM_Boson_Fermion\nM_Boson_Fermion(Hsys, tier_b::Int, tier_f::Int, Bath_b::Vector{BosonBath}, Bath_f::Vector{FermionBath}, parity::Symbol=:even; threshold::Real=0.0, verbose::Bool=true)\nsize(M::AbstractHEOMMatrix)\nPropagator\naddBosonDissipator\naddFermionDissipator\naddTerminator","category":"page"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.M_S","page":"Library API","title":"HierarchicalEOM.HeomAPI.M_S","text":"struct M_S <: AbstractHEOMMatrix\n\nHEOM Liouvillian superoperator matrix with cutoff level of the hierarchy equals to 0.   This corresponds to the standard Schrodinger (Liouville-von Neumann) equation, namely\n\nMcdot=-i leftH_sys cdot right_-\n\nwhere cdot cdot_- stands for commutator.\n\nFields\n\ndata : the sparse matrix of HEOM Liouvillian superoperator\ntier : the tier (cutoff level) for the hierarchy, which equals to 0 in this case\ndim : the dimension of system\nN : the number of total ADOs, which equals to 1 (only the reduced density operator) in this case\nsup_dim : the dimension of system superoperator\nparity : the parity label of the fermionic system (usually :even, only set as :odd for calculating spectrum of fermionic system)\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.M_S-2","page":"Library API","title":"HierarchicalEOM.HeomAPI.M_S","text":"M_S(Hsys, parity=:even; verbose=true)\n\nGenerate HEOM Liouvillian superoperator matrix with cutoff level of the hierarchy equals to 0.   This corresponds to the standard Schrodinger (Liouville-von Neumann) equation, namely\n\nMcdot=-i leftH_sys cdot right_-\n\nwhere cdot cdot_- stands for commutator.\n\nParameters\n\nHsys : The time-independent system Hamiltonian\nparity::Symbol : the parity label of the fermionic system (only set as :odd for calculating spectrum of fermionic system). Defaults to :even.\nverbose::Bool : To display verbose output during the process or not. Defaults to true.\n\nNote that the parity only need to be set as :odd when the system contains fermionic systems and you need to calculate the spectrum (density of states) of it.\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.M_Boson","page":"Library API","title":"HierarchicalEOM.HeomAPI.M_Boson","text":"struct M_Boson <: AbstractHEOMMatrix\n\nHEOM Liouvillian superoperator matrix for bosonic bath\n\nFields\n\ndata : the sparse matrix of HEOM Liouvillian superoperator\ntier : the tier (cutoff level) for the bosonic hierarchy\ndim : the dimension of system\nN : the number of total ADOs\nsup_dim : the dimension of system superoperator\nparity : the parity label of the fermionic system (usually :even, only set as :odd for calculating spectrum of fermionic system).\nbath::Vector{BosonBath} : the vector which stores all BosonBath objects\nhierarchy::HierarchyDict: the object which contains all dictionaries for boson-bath-ADOs hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.M_Boson-2","page":"Library API","title":"HierarchicalEOM.HeomAPI.M_Boson","text":"M_Boson(Hsys, tier, Bath, parity=:even; threshold=0.0, verbose=true)\n\nGenerate the boson-type HEOM Liouvillian superoperator matrix\n\nParameters\n\nHsys : The time-independent system Hamiltonian\ntier::Int : the tier (cutoff level) for the bosonic bath\nBath::Vector{BosonBath} : objects for different bosonic baths\nparity::Symbol : the parity label of the fermionic system (only set as :odd for calculating spectrum of fermionic system). Defaults to :even.\nthreshold::Real : The threshold of the importance value (see Ref. [1]). Defaults to 0.0.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\n\nNote that the parity only need to be set as :odd when the system contains fermionic systems and you need to calculate the spectrum (density of states) of it.\n\n[1] Phys. Rev. B 88, 235426 (2013)\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.M_Fermion","page":"Library API","title":"HierarchicalEOM.HeomAPI.M_Fermion","text":"struct M_Fermion <: AbstractHEOMMatrix\n\nHEOM Liouvillian superoperator matrix for fermionic bath\n\nFields\n\ndata : the sparse matrix of HEOM Liouvillian superoperator\ntier : the tier (cutoff level) for the fermionic hierarchy\ndim : the dimension of system\nN : the number of total ADOs\nsup_dim : the dimension of system superoperator\nparity : the parity label of the fermionic system (usually :even, only set as :odd for calculating spectrum of fermionic system)\nbath::Vector{FermionBath} : the vector which stores all FermionBath objects\nhierarchy::HierarchyDict: the object which contains all dictionaries for fermion-bath-ADOs hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.M_Fermion-2","page":"Library API","title":"HierarchicalEOM.HeomAPI.M_Fermion","text":"M_Fermion(Hsys, tier, Bath, parity=:even; threshold=0.0, verbose=true)\n\nGenerate the fermion-type HEOM Liouvillian superoperator matrix\n\nParameters\n\nHsys : The time-independent system Hamiltonian\ntier::Int : the tier (cutoff level) for the fermionic bath\nBath::Vector{FermionBath} : objects for different fermionic baths\nparity::Symbol : the parity label of the fermionic system (only set as :odd for calculating spectrum of fermionic system). Defaults to :even.\nthreshold::Real : The threshold of the importance value (see Ref. [1]). Defaults to 0.0.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\n\n[1] Phys. Rev. B 88, 235426 (2013)\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.M_Boson_Fermion","page":"Library API","title":"HierarchicalEOM.HeomAPI.M_Boson_Fermion","text":"struct M_Boson_Fermion <: AbstractHEOMMatrix\n\nHEOM Liouvillian superoperator matrix for mixtured (bosonic and fermionic) bath \n\nFields\n\ndata : the sparse matrix of HEOM Liouvillian superoperator\nBtier : the tier (cutoff level) for bosonic hierarchy\nFtier : the tier (cutoff level) for fermionic hierarchy\ndim : the dimension of system\nN : the number of total ADOs\nsup_dim : the dimension of system superoperator\nparity : the parity label of the fermionic system (usually :even, only set as :odd for calculating spectrum of fermionic system).\nBbath::Vector{BosonBath} : the vector which stores all BosonBath objects\nFbath::Vector{FermionBath} : the vector which stores all FermionBath objects\nhierarchy::MixHierarchyDict: the object which contains all dictionaries for mixed-bath-ADOs hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.M_Boson_Fermion-2","page":"Library API","title":"HierarchicalEOM.HeomAPI.M_Boson_Fermion","text":"M_Boson_Fermion(Hsys, Btier, Ftier, Bbath, Fbath, parity=:even; threshold=0.0, verbose=true)\n\nGenerate the boson-fermion-type HEOM Liouvillian superoperator matrix\n\nParameters\n\nHsys : The time-independent system Hamiltonian\nBtier::Int : the tier (cutoff level) for the bosonic bath\nFtier::Int : the tier (cutoff level) for the fermionic bath\nBbath::Vector{BosonBath} : objects for different bosonic baths\nFbath::Vector{FermionBath} : objects for different fermionic baths\nparity::Symbol : the parity label of the fermionic system (only set as :odd for calculating spectrum of fermionic system). Defaults to :even.\nthreshold::Real : The threshold of the importance value (see Ref. [1, 2]). Defaults to 0.0.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\n\nNote that the parity only need to be set as :odd when the system contains fermion systems and you need to calculate the spectrum of it.\n\n[1] Phys. Rev. B  88, 235426 (2013) [2] Phys. Rev. B 103, 235413 (2021)\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#Base.size-Tuple{AbstractHEOMMatrix}","page":"Library API","title":"Base.size","text":"size(M::AbstractHEOMMatrix)\n\nReturns the size of the HEOM Liouvillian superoperator matrix\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.Propagator","page":"Library API","title":"HierarchicalEOM.HeomAPI.Propagator","text":"Propagator(M, Δt; threshold, nonzero_tol)\n\nUse FastExpm.jl to calculate the propagator matrix from a given HEOM Liouvillian superoperator matrix M with a specific time step Delta t. That is, exp(M * Delta t).\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model\nΔt::Real : A specific time step (time interval).\nthreshold::Real : Determines the threshold for the Taylor series. Defaults to 1.0e-6.\nnonzero_tol::Real : Strips elements smaller than nonzero_tol at each computation step to preserve sparsity. Defaults to 1.0e-14.\n\nFor more details, please refer to FastExpm.jl\n\nReturns\n\n::SparseMatrixCSC{ComplexF64, Int64} : the propagator matrix\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.addBosonDissipator","page":"Library API","title":"HierarchicalEOM.HeomAPI.addBosonDissipator","text":"addBosonDissipator(M, jumpOP)\n\nAdding bosonic dissipator to a given HEOM matrix which describes how the system dissipatively interacts with an extra bosonic environment.   The dissipator is defined as follows\n\nDJ(cdot) = J(cdot) J^dagger - frac12left(J^dagger J (cdot) + (cdot) J^dagger J right)\n\nwhere Jequiv sqrtgammaV is the jump operator, V describes the dissipative part (operator) of the dynamics, gamma represents a non-negative damping rate and cdot cdot_+ stands for anti-commutator.\n\nNote that if V is acting on fermionic systems, it should be even-parity to be compatible with charge conservation.\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model\njumpOP::AbstractVector : The list of collapse (jump) operators J_i_i to add. Defaults to empty vector [].\n\nReturn\n\nM_new::AbstractHEOMMatrix : the new HEOM Liouvillian superoperator matrix\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.addFermionDissipator","page":"Library API","title":"HierarchicalEOM.HeomAPI.addFermionDissipator","text":"addFermionDissipator(M, jumpOP)\n\nAdding fermionic dissipator to a given HEOM matrix which describes how the system dissipatively interacts with an extra fermionic environment.   The dissipator with :even parity is defined as follows\n\nD_textrmevenJ(cdot) = J(cdot) J^dagger - frac12left(J^dagger J (cdot) + (cdot) J^dagger J right)\n\nwhere Jequiv sqrtgammaV is the jump operator, V describes the dissipative part (operator) of the dynamics, gamma represents a non-negative damping rate and cdot cdot_+ stands for anti-commutator.\n\nSimilary, the dissipator with :odd parity is defined as follows\n\nD_textrmoddJ(cdot) = - J(cdot) J^dagger - frac12left(J^dagger J (cdot) + (cdot) J^dagger J right)\n\nNote that the parity of the dissipator will be determined by the parity of the given HEOM matrix M.\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model\njumpOP::AbstractVector : The list of collapse (jump) operators to add. Defaults to empty vector [].\n\nReturn\n\nM_new::AbstractHEOMMatrix : the new HEOM Liouvillian superoperator matrix\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.addTerminator","page":"Library API","title":"HierarchicalEOM.HeomAPI.addTerminator","text":"addTerminator(M, Bath)\n\nAdding terminator to a given HEOM matrix.\n\nThe terminator is a Liouvillian term representing the contribution to  the system-bath dynamics of all exponential-expansion terms beyond Bath.Nterm\n\nThe difference between the true correlation function and the sum of the  Bath.Nterm-exponential terms is approximately 2 * δ * dirac(t). Here, δ is the approximation discrepancy and dirac(t) denotes the Dirac-delta function.\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model\nBath::Union{BosonBath, FermionBath} : The bath object which contains the approximation discrepancy δ\n\nReturn\n\nM_new::AbstractHEOMMatrix : the new HEOM Liouvillian superoperator matrix\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#Auxiliary-Density-Operators-(ADOs)","page":"Library API","title":"Auxiliary Density Operators (ADOs)","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"ADOs\nADOs(V::AbstractVector, N::Int)\nlength(A::ADOs)\ngetRho\ngetADO\nExpect","category":"page"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.ADOs","page":"Library API","title":"HierarchicalEOM.HeomAPI.ADOs","text":"mutable struct ADOs\n\nThe Auxiliary Density Operators for HEOM model.\n\nFields\n\ndata : the vectorized auxiliary density operators\ndim : the dimension of the system\nN : the number of auxiliary density operators\n\nMethods\n\nOne can obtain the density matrix for specific index (idx) by calling : ados[idx]. HierarchicalEOM.jl also supports the following calls (methods) :\n\nlength(ados);  # returns the total number of `ADOs`\nados[1:idx];   # returns a vector which contains the `ADO` (in matrix form) from index `1` to `idx`\nados[1:end];   # returns a vector which contains all the `ADO` (in matrix form)\nados[:];       # returns a vector which contains all the `ADO` (in matrix form)\nfor rho in ados  # iteration\n    # do something\nend\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.ADOs-Tuple{AbstractVector, Int64}","page":"Library API","title":"HierarchicalEOM.HeomAPI.ADOs","text":"ADOs(V, N)\n\nGernerate the object of auxiliary density operators for HEOM model.\n\nParameters\n\nV::AbstractVector : the vectorized auxiliary density operators\nN::Int : the number of auxiliary density operators.\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#Base.length-Tuple{ADOs}","page":"Library API","title":"Base.length","text":"length(A::ADOs)\n\nReturns the total number of the Auxiliary Density Operators (ADOs)\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.getRho","page":"Library API","title":"HierarchicalEOM.HeomAPI.getRho","text":"getRho(ados)\n\nReturn the density matrix of the reduced state (system) from a given auxiliary density operators\n\nParameters\n\nados::ADOs : the auxiliary density operators for HEOM model\n\nReturns\n\nρ : The density matrix of the reduced state\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.getADO","page":"Library API","title":"HierarchicalEOM.HeomAPI.getADO","text":"getADO(ados, idx)\n\nReturn the auxiliary density operator with a specific index from auxiliary density operators\n\nThis function equals to calling : ados[idx].\n\nParameters\n\nados::ADOs : the auxiliary density operators for HEOM model\nidx::Int : the index of the auxiliary density operator\n\nReturns\n\nρ_idx : The auxiliary density operator\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.Expect","page":"Library API","title":"HierarchicalEOM.HeomAPI.Expect","text":"Expect(op, ados; take_real=true)\n\nReturn the expectation value of the operator op for the reduced density operator in the given ados, namely\n\ntextrmRelefttextrmTrleft O rho rightright\n\nwhere O is the operator and rho is the reduced density operator in the given ADOs.\n\nParameters\n\nop : the operator O to take the expectation value\nados::ADOs : the auxiliary density operators for HEOM model\ntake_real::Bool : whether to automatically take the real part of the trace or not. Default to true\n\nReturns\n\nexp_val : The expectation value\n\n\n\n\n\nExpect(op, ados_list; take_real=true)\n\nReturn a list of expectation values of the operator op corresponds to the reduced density operators in the given ados_list, namely\n\ntextrmRelefttextrmTrleft O rho rightright\n\nwhere O is the operator and rho is the reduced density operator in one of the ADOs from ados_list.\n\nParameters\n\nop : the operator O to take the expectation value\nados_list::Vector{ADOs} : the list of auxiliary density operators for HEOM model\ntake_real::Bool : whether to automatically take the real part of the trace or not. Default to true\n\nReturns\n\nexp_val : The expectation value\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#lib-Hierarchy-Dictionary","page":"Library API","title":"Hierarchy Dictionary","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"Nvec\nHierarchyDict\nMixHierarchyDict\ngetIndexEnsemble","category":"page"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.Nvec","page":"Library API","title":"HierarchicalEOM.HeomAPI.Nvec","text":"struct Nvec\n\nAn object which describes the repetition number of each multi-index ensembles in auxiliary density operators.\n\nThe n_vector (vecn) denotes a set of integers:\n\n n_11  n_alpha k  \n\nassociated with the k-th exponential-expansion term in the alpha-th bath. If n_alpha k = 3 means that the multi-index ensemble alpha k appears three times in the multi-index vector of ADOs (see the notations in our paper).\n\nThe hierarchy level (L) for an n_vector is given by L=sum_alpha k n_alpha k\n\nFields\n\ndata : the n_vector\nlevel : The level L for the n_vector\n\nMethods\n\nOne can obtain the repetition number for specific index (idx) by calling : n_vector[idx]. To obtain the corresponding tuple (alpha k) for a given index idx, see bathPtr in HierarchyDict for more details.\n\nHierarchicalEOM.jl also supports the following calls (methods) :\n\nlength(n_vector);  # returns the length of `Nvec`\nn_vector[1:idx];   # returns a vector which contains the excitation number of `n_vector` from index `1` to `idx`\nn_vector[1:end];   # returns a vector which contains all the excitation number of `n_vector`\nn_vector[:];       # returns a vector which contains all the excitation number of `n_vector`\nfrom n in n_vector  # iteration\n    # do something\nend\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.HierarchyDict","page":"Library API","title":"HierarchicalEOM.HeomAPI.HierarchyDict","text":"struct HierarchyDict <: AbstractHierarchyDict\n\nAn object which contains all dictionaries for pure (bosonic or fermionic) bath-ADOs hierarchy.\n\nFields\n\nidx2nvec : Return the Nvec from a given index of ADO\nnvec2idx : Return the index of ADO from a given Nvec\nlvl2idx : Return the list of ADO-indices from a given hierarchy level\nbathPtr : Records the tuple (alpha k) for each position in Nvec, where alpha and k represents the k-th exponential-expansion term of the alpha-th bath.\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.MixHierarchyDict","page":"Library API","title":"HierarchicalEOM.HeomAPI.MixHierarchyDict","text":"struct MixHierarchyDict <: AbstractHierarchyDict\n\nAn object which contains all dictionaries for mixed (bosonic and fermionic) bath-ADOs hierarchy.\n\nFields\n\nidx2nvec : Return the tuple (Nvec_b, Nvec_f) from a given index of ADO, where b represents boson and f represents fermion\nnvec2idx : Return the index from a given tuple (Nvec_b, Nvec_f), where b represents boson and f represents fermion\nBlvl2idx : Return the list of ADO-indices from a given bosonic-hierarchy level\nFlvl2idx : Return the list of ADO-indices from a given fermionic-hierarchy level\nbosonPtr : Records the tuple (alpha k) for each position in Nvec_b, where alpha and k represents the k-th exponential-expansion term of the alpha-th bosonic bath.\nfermionPtr : Records the tuple (alpha k) for each position in Nvec_f, where alpha and k represents the k-th exponential-expansion term of the alpha-th fermionic bath.\n\n\n\n\n\n","category":"type"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.getIndexEnsemble","page":"Library API","title":"HierarchicalEOM.HeomAPI.getIndexEnsemble","text":"getIndexEnsemble(nvec, bathPtr)\n\nSearch for all the multi-index ensemble (alpha k) where alpha and k represents the k-th exponential-expansion term in the alpha-th bath.\n\nParameters\n\nnvec::Nvec : An object which records the repetition number of each multi-index ensembles in ADOs.\nbathPtr::Vector{Tuple{Int, Int}}: This can be obtained from HierarchyDict.bathPtr, MixHierarchyDict.bosonPtr, or MixHierarchyDict.fermionPtr.\n\nReturns\n\nVector{Tuple{Int, Int, Int}}: a vector (list) of the tuples (alpha k n).\n\nExample\n\nHere is an example to use Bath, Exponent, HierarchyDict, and getIndexEnsemble together:\n\nL::M_Fermion;          # suppose this is a fermion type of HEOM Liouvillian superoperator matrix you create\nHDict = L.hierarchy;   # the hierarchy dictionary\nados = SteadyState(L); # the stationary state (ADOs) for L \n\n# Let's consider all the ADOs for first level\nidx_list = HDict.lvl2idx[1];\n\nfor idx in idx_list\n    ρ1 = ados[idx]  # one of the 1st-level ADO\n    nvec = HDict.idx2nvec[idx]  # the nvec corresponding to ρ1\n    \n    for (α, k, n) in getIndexEnsemble(nvec, HDict.bathPtr)\n        α  # index of the bath\n        k  # the index of the exponential-expansion term in α-th bath\n        n  # the repetition number of the ensemble {α, k} in ADOs\n        exponent = L.bath[α][k]  # the k-th exponential-expansion term in α-th bath\n\n        # do some calculations you want\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#lib-Time-Evolution","page":"Library API","title":"Time Evolution","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"There are six function definitions of evolution, which depend on different input types and methods to solve the time evolution:","category":"page"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"evolution","category":"page"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.evolution","page":"Library API","title":"HierarchicalEOM.HeomAPI.evolution","text":"evolution(M, ρ0, Δt, steps; threshold, nonzero_tol, verbose, filename)\n\nSolve the time evolution for auxiliary density operators based on propagator (generated by FastExpm.jl) with initial state is given in the type of density-matrix (ρ0).\n\nThis method will return the time evolution of ADOs corresponds to tlist = 0 : Δt : (Δt * steps)\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model\nρ0 : system initial state (density matrix)\nΔt::Real : A specific time step (time interval).\nsteps::Int : The number of time steps\nthreshold::Real : Determines the threshold for the Taylor series. Defaults to 1.0e-6.\nnonzero_tol::Real : Strips elements smaller than nonzero_tol at each computation step to preserve sparsity. Defaults to 1.0e-14.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nfilename::String : If filename was specified, the ADOs at each time point will be saved into the JLD2 file \"filename.jld2\" during the solving process.\n\nFor more details, please refer to FastExpm.jl\n\nReturns\n\nADOs_list : The auxiliary density operators of each time step.\n\n\n\n\n\nevolution(M, ados, Δt, steps; threshold, nonzero_tol, verbose, filename)\n\nSolve the time evolution for auxiliary density operators based on propagator (generated by FastExpm.jl) with initial state is given in the type of ADOs.\n\nThis method will return the time evolution of ADOs corresponds to tlist = 0 : Δt : (Δt * steps)\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model\nados::ADOs : initial auxiliary density operators\nΔt::Real : A specific time step (time interval).\nsteps::Int : The number of time steps\nthreshold::Real : Determines the threshold for the Taylor series. Defaults to 1.0e-6.\nnonzero_tol::Real : Strips elements smaller than nonzero_tol at each computation step to preserve sparsity. Defaults to 1.0e-14.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nfilename::String : If filename was specified, the ADOs at each time point will be saved into the JLD2 file \"filename.jld2\" during the solving process.\n\nFor more details, please refer to FastExpm.jl\n\nReturns\n\nADOs_list : The auxiliary density operators of each time step.\n\n\n\n\n\nevolution(M, ρ0, tlist; solver, reltol, abstol, maxiters, save_everystep, verbose, filename, SOLVEROptions...)\n\nSolve the time evolution for auxiliary density operators based on ordinary differential equations with initial state is given in the type of density-matrix (ρ0).\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model\nρ0 : system initial state (density matrix)\ntlist::AbstractVector : Denote the specific time points to save the solution at, during the solving process.\nsolver : solver in package DifferentialEquations.jl. Default to DP5().\nreltol::Real : Relative tolerance in adaptive timestepping. Default to 1.0e-6.\nabstol::Real : Absolute tolerance in adaptive timestepping. Default to 1.0e-8.\nmaxiters::Real : Maximum number of iterations before stopping. Default to 1e5.\nsave_everystep::Bool : Saves the result at every step. Defaults to false.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nfilename::String : If filename was specified, the ADOs at each time point will be saved into the JLD2 file \"filename.jld2\" during the solving process.\nSOLVEROptions : extra options for solver\n\nFor more details about solvers and extra options, please refer to DifferentialEquations.jl\n\nReturns\n\nADOs_list : The auxiliary density operators in each time point.\n\n\n\n\n\nevolution(M, ados, tlist; solver, reltol, abstol, maxiters, save_everystep, verbose, filename, SOLVEROptions...)\n\nSolve the time evolution for auxiliary density operators based on ordinary differential equations with initial state is given in the type of ADOs.\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model\nados::ADOs : initial auxiliary density operators\ntlist::AbstractVector : Denote the specific time points to save the solution at, during the solving process.\nsolver : solver in package DifferentialEquations.jl. Default to DP5().\nreltol::Real : Relative tolerance in adaptive timestepping. Default to 1.0e-6.\nabstol::Real : Absolute tolerance in adaptive timestepping. Default to 1.0e-8.\nmaxiters::Real : Maximum number of iterations before stopping. Default to 1e5.\nsave_everystep::Bool : Saves the result at every step. Defaults to false.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nfilename::String : If filename was specified, the ADOs at each time point will be saved into the JLD2 file \"filename.jld2\" during the solving process.\nSOLVEROptions : extra options for solver\n\nFor more details about solvers and extra options, please refer to DifferentialEquations.jl\n\nReturns\n\nADOs_list : The auxiliary density operators in each time point.\n\n\n\n\n\nevolution(M, ρ0, tlist, H, param; solver, reltol, abstol, maxiters, save_everystep, verbose, filename, SOLVEROptions...)\n\nSolve the time evolution for auxiliary density operators with time-dependent system Hamiltonian based on ordinary differential equations with initial state is given in the type of density-matrix (ρ0).\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model (with time-independent system Hamiltonian)\nρ0 : system initial state (density matrix)\ntlist::AbstractVector : Denote the specific time points to save the solution at, during the solving process.\nH::Function : a function for time-dependent part of system Hamiltonian. The function will be called by H(param, t) and should return the time-dependent part system Hamiltonian matrix at time t with AbstractMatrix type.\nparam::Tuple: the tuple of parameters which is used to call H(param, t) for the time-dependent system Hamiltonian. Default to empty tuple ().\nsolver : solver in package DifferentialEquations.jl. Default to DP5().\nreltol::Real : Relative tolerance in adaptive timestepping. Default to 1.0e-6.\nabstol::Real : Absolute tolerance in adaptive timestepping. Default to 1.0e-8.\nmaxiters::Real : Maximum number of iterations before stopping. Default to 1e5.\nsave_everystep::Bool : Saves the result at every step. Defaults to false.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nfilename::String : If filename was specified, the ADOs at each time point will be saved into the JLD2 file \"filename.jld2\" during the solving process.\nSOLVEROptions : extra options for solver\n\nFor more details about solvers and extra options, please refer to DifferentialEquations.jl\n\nReturns\n\nADOs_list : The auxiliary density operators in each time point.\n\n\n\n\n\nevolution(M, ados, tlist, H, param; solver, reltol, abstol, maxiters, save_everystep, verbose, filename, SOLVEROptions...)\n\nSolve the time evolution for auxiliary density operators with time-dependent system Hamiltonian based on ordinary differential equations with initial state is given in the type of ADOs.\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model (with time-independent system Hamiltonian)\nados::ADOs : initial auxiliary density operators\ntlist::AbstractVector : Denote the specific time points to save the solution at, during the solving process.\nH::Function : a function for time-dependent part of system Hamiltonian. The function will be called by H(param, t) and should return the time-dependent part system Hamiltonian matrix at time t with AbstractMatrix type.\nparam::Tuple: the tuple of parameters which is used to call H(param, t) for the time-dependent system Hamiltonian. Default to empty tuple ().\nsolver : solver in package DifferentialEquations.jl. Default to DP5().\nreltol::Real : Relative tolerance in adaptive timestepping. Default to 1.0e-6.\nabstol::Real : Absolute tolerance in adaptive timestepping. Default to 1.0e-8.\nmaxiters::Real : Maximum number of iterations before stopping. Default to 1e5.\nsave_everystep::Bool : Saves the result at every step. Defaults to false.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nfilename::String : If filename was specified, the ADOs at each time point will be saved into the JLD2 file \"filename.jld2\" during the solving process.\nSOLVEROptions : extra options for solver\n\nFor more details about solvers and extra options, please refer to DifferentialEquations.jl\n\nReturns\n\nADOs_list : The auxiliary density operators in each time point.\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#Steady-State","page":"Library API","title":"Steady State","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"There are three function definitions of SteadyState, which depend on different input types and methods to solve the stationary state:","category":"page"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"SteadyState","category":"page"},{"location":"libraryAPI/#HierarchicalEOM.HeomAPI.SteadyState","page":"Library API","title":"HierarchicalEOM.HeomAPI.SteadyState","text":"SteadyState(M; solver, verbose, SOLVEROptions...)\n\nSolve the steady state of the auxiliary density operators based on LinearSolve.jl (i.e., solving x where A times x = b).\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model, where the parity should be :even.\nsolver : solver in package LinearSolve.jl. Default to UMFPACKFactorization().\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nSOLVEROptions : extra options for solver \n\nFor more details about solvers and extra options, please refer to LinearSolve.jl\n\nReturns\n\n::ADOs : The steady state of auxiliary density operators.\n\n\n\n\n\nSteadyState(M, ρ0; solver, reltol, abstol, maxiters, save_everystep, verbose, SOLVEROptions...)\n\nSolve the steady state of the auxiliary density operators based on time evolution (ordinary differential equations) with initial state is given in the type of density-matrix (ρ0).\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model, where the parity should be :even.\nρ0 : system initial state (density matrix)\nsolver : The ODE solvers in package DifferentialEquations.jl. Default to DP5().\nreltol::Real : Relative tolerance in adaptive timestepping. Default to 1.0e-6.\nabstol::Real : Absolute tolerance in adaptive timestepping. Default to 1.0e-8.\nmaxiters::Real : Maximum number of iterations before stopping. Default to 1e5.\nsave_everystep::Bool : Saves the result at every step. Defaults to false.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nSOLVEROptions : extra options for solver\n\nFor more details about solvers and extra options, please refer to DifferentialEquations.jl\n\nReturns\n\n::ADOs : The steady state of auxiliary density operators.\n\n\n\n\n\nSteadyState(M, ados; solver, reltol, abstol, maxiters, save_everystep, verbose, SOLVEROptions...)\n\nSolve the steady state of the auxiliary density operators based on time evolution (ordinary differential equations) with initial state is given in the type of ADOs.\n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model, where the parity should be :even.\nados::ADOs : initial auxiliary density operators\nsolver : The ODE solvers in package DifferentialEquations.jl. Default to DP5().\nreltol::Real : Relative tolerance in adaptive timestepping. Default to 1.0e-3.\nabstol::Real : Absolute tolerance in adaptive timestepping. Default to 1.0e-6.\nmaxiters::Real : Maximum number of iterations before stopping. Default to 1e5.\nsave_everystep::Bool : Saves the result at every step. Defaults to false.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nSOLVEROptions : extra options for solver\n\nFor more details about solvers and extra options, please refer to DifferentialEquations.jl\n\nReturns\n\n::ADOs : The steady state of auxiliary density operators.\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#Spectrum","page":"Library API","title":"Spectrum","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"spectrum","category":"page"},{"location":"libraryAPI/#HierarchicalEOM.Spectrum.spectrum","page":"Library API","title":"HierarchicalEOM.Spectrum.spectrum","text":"spectrum(M, ρ, op, ω_list; solver, verbose, filename, SOLVEROptions...)\n\nCalculate spectrum for the system.\n\nTo calculate spectrum for bosonic systems (usually known as power spectrum):\n\npi S(omega)=textrmReleftint_0^infty dt langle a^dagger(t) a(0)rangle e^-iomega tright\n\nremember to set the parameters: \n\nM::AbstractHEOMMatrix: should be :even parity\nop: the (annihilation) operator a for bosonic system as shown above \n\nTo calculate spectrum for fermionic systems (usually known as density of states):\n\n    pi A(omega)=textrmReleftint_0^infty dt leftlangle d(t) d^dagger(0)rangle^* + langle d^dagger(t) d(0)rangle right e^-iomega tright\n\nremember to set the parameters: \n\nM::AbstractHEOMMatrix: should be :odd parity\nop: the (annihilation) operator d for fermionic system as shown above \n\nParameters\n\nM::AbstractHEOMMatrix : the matrix given from HEOM model.\nρ :  the system density matrix or the auxiliary density operators.\nop : The annihilation operator acting on the system.\nω_list::AbstractVector : the specific frequency points to solve.\nsolver : solver in package LinearSolve.jl. Default to UMFPACKFactorization().\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.\nfilename::String : If filename was specified, the value of spectrum for each ω will be saved into the file \"filename.txt\" during the solving process.\nSOLVEROptions : extra options for solver \n\nFor more details about solvers and extra options, please refer to LinearSolve.jl\n\nReturns\n\nspec::AbstractVector : the spectrum list corresponds to the specified ω_list\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/#Misc.","page":"Library API","title":"Misc.","text":"","category":"section"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"HierarchicalEOM.versioninfo()","category":"page"},{"location":"libraryAPI/#HierarchicalEOM.HeomBase.versioninfo-Tuple{}","page":"Library API","title":"HierarchicalEOM.HeomBase.versioninfo","text":"HierarchicalEOM.versioninfo(io::IO=stdout)\n\nCommand line output of information on HierarchicalEOM, dependencies, and system informations.\n\n\n\n\n\n","category":"method"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"The outputs will be something like the following:","category":"page"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"using HierarchicalEOM\nHierarchicalEOM.versioninfo()","category":"page"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"HierarchicalEOM.print_logo(io::IO=stdout)","category":"page"},{"location":"libraryAPI/#HierarchicalEOM.HeomBase.print_logo","page":"Library API","title":"HierarchicalEOM.HeomBase.print_logo","text":"HierarchicalEOM.print_logo(io::IO=stdout)\n\nPrint the Logo of HierarchicalEOM package\n\n\n\n\n\n","category":"function"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"The output will be something like the following:","category":"page"},{"location":"libraryAPI/","page":"Library API","title":"Library API","text":"using HierarchicalEOM\nHierarchicalEOM.print_logo()","category":"page"},{"location":"heom_matrix/master_eq/#doc-Master-Equation","page":"HEOMLS for Master Equation","title":"HEOMLS Matrix for Master Equation","text":"","category":"section"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"HierarchicalEOM.jl allows users to further add the Lindbladian (superoperator) on any types (AbstractHEOMMatrix) of HEOM Liouvillian superoperator hatmathcalM. The Lindbladian describes the dissipative interaction between the system and extra environment.","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"This method is more efficient than the full HEOM when some of the baths are weakly coupled to the system since it does not require any extra ADOs space to describe the dynamics and hence reduces the size of hatmathcalM.","category":"page"},{"location":"heom_matrix/master_eq/#Bosonic-Dissipative-Env.","page":"HEOMLS for Master Equation","title":"Bosonic Dissipative Env.","text":"","category":"section"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"If the system is weakly coupled to an extra bosonic environment, the explicit form of the Lindbladian is given by","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"hatmathcalD(J)BigcdotBig=JleftcdotrightJ^dagger-frac12BigJ^dagger J cdotBig_+","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"where Jequiv sqrtgammaV is the jump operator, V describes the dissipative part (operator) of the dynamics, gamma represents a non-negative damping rate and cdot cdot_+ stands for anti-commutator.","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"note: Note\nThe system here can be either bosonic or fermionic. However, if V is acting on fermionic systems, it should be even-parity to be compatible with charge conservation.","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"One can add the Lindbladian hatmathcalD of bosonic environment to the HEOM Liouvillian superoperator hatmathcalM by calling ","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"addBosonDissipator(M::AbstractHEOMMatrix, jumpOP) with the parameters:","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"M::AbstractHEOMMatrix : the matrix given from HEOM model\njumpOP::AbstractVector : The list of collapse (jump) operators J_i_i to add. Defaults to empty vector [].","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"Finally, the function returns a new hatmathcalM with the same type:","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"M0::AbstractHEOMMatrix\nJ = [J1, J2, ..., Jn]  # jump operators\n\nM1 = addBosonDissipator(M0, J)","category":"page"},{"location":"heom_matrix/master_eq/#Fermionic-Dissipative-Env.","page":"HEOMLS for Master Equation","title":"Fermionic Dissipative Env.","text":"","category":"section"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"If the fermionic system is weakly coupled to an extra fermionic environment, the explicit form of the Lindbladian acting on :even-parity operators is given by","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"hatmathcalD_textrmeven(J)BigcdotBig=JleftcdotrightJ^dagger-frac12BigJ^dagger J cdotBig_+","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"where Jequiv sqrtgammaV is the jump operator, V describes the dissipative part (operator) of the dynamics, gamma represents a non-negative damping rate and cdot cdot_+ stands for anti-commutator.","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"For acting on :odd-parity operators, the explicit form of the Lindbladian is given by","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"hatmathcalD_textrmodd(J)BigcdotBig=-JleftcdotrightJ^dagger-frac12BigJ^dagger J cdotBig_+","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"One can add the Lindbladian hatmathcalD of fermionic environment to the HEOM Liouvillian superoperator hatmathcalM by calling ","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"addFermionDissipator(M::AbstractHEOMMatrix, jumpOP) with the parameters:","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"M::AbstractHEOMMatrix : the matrix given from HEOM model\njumpOP::AbstractVector : The list of collapse (jump) operators J_i_i to add. Defaults to empty vector [].","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"note: Parity\nThe parity of the dissipator will be automatically determined by the parity of the given HEOM matrix M.","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"Finally, the function returns a new hatmathcalM with the same type and parity:","category":"page"},{"location":"heom_matrix/master_eq/","page":"HEOMLS for Master Equation","title":"HEOMLS for Master Equation","text":"M0_even::AbstractHEOMMatrix # constructed with :even-parity\nM0_odd::AbstractHEOMMatrix  # constructed with :odd-parity\nJ = [J1, J2, ..., Jn]  # jump operators\n\nM1_even = addFermionDissipator(M0_even, J)\nM1_odd  = addFermionDissipator(M0_odd,  J)","category":"page"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"EditURL = \"../../../examples/benchmark_LS_solvers.jl\"","category":"page"},{"location":"examples/benchmark_LS_solvers/#benchmark-LS-solvers","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"In this page, we will benchmark several solvers provided by LinearSolve.jl for solving SteadyState and spectrum in hierarchical equations of motion approach.","category":"page"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"using LinearSolve\nusing BenchmarkTools\nusing HierarchicalEOM\nHierarchicalEOM.versioninfo()","category":"page"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"Here, we use the example of the single-impurity Anderson model:","category":"page"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"ϵ = -5\nU = 10\nΓ = 2\nμ = 0\nW = 10\nT = 0.5\nN = 5\ntier = 2\nωlist = -10:1:10\n\nσm = [0 1; 0  0]\nσz = [1 0; 0 -1]\nII = [1 0; 0  1]\nd_up = kron(     σm, II)\nd_dn = kron(-1 * σz, σm)\nHsys = ϵ * (d_up' * d_up + d_dn' * d_dn) + U * (d_up' * d_up * d_dn' * d_dn)\n\nbath_up = Fermion_Lorentz_Pade(d_up, Γ, μ, W, T, N)\nbath_dn = Fermion_Lorentz_Pade(d_dn, Γ, μ, W, T, N)\nbath_list = [bath_up, bath_dn]\nM_even = M_Fermion(Hsys, tier, bath_list)\nM_odd  = M_Fermion(Hsys, tier, bath_list, :odd)\nados_s = SteadyState(M_even);\nnothing #hide","category":"page"},{"location":"examples/benchmark_LS_solvers/#LinearSolve-Solver-List","page":"LinearSolve solvers","title":"LinearSolve Solver List","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"(click here to see the full solver list provided by LinearSolve.jl)","category":"page"},{"location":"examples/benchmark_LS_solvers/#UMFPACKFactorization-(Default-solver)","page":"LinearSolve solvers","title":"UMFPACKFactorization (Default solver)","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"This solver performs better when there is more structure to the sparsity pattern (depends on the complexity of your system and baths).","category":"page"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"umf_solver = UMFPACKFactorization();\nnothing #hide","category":"page"},{"location":"examples/benchmark_LS_solvers/#KLUFactorization","page":"LinearSolve solvers","title":"KLUFactorization","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"This solver performs better when there is less structure to the sparsity pattern (depends on the complexity of your system and baths).","category":"page"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"klu_solver = KLUFactorization();\nnothing #hide","category":"page"},{"location":"examples/benchmark_LS_solvers/#Julia's-built-in-LU-factorization","page":"LinearSolve solvers","title":"Julia's built-in LU factorization","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"julia_solver = LUFactorization();\nnothing #hide","category":"page"},{"location":"examples/benchmark_LS_solvers/#Pardiso","page":"LinearSolve solvers","title":"Pardiso","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"This solver is based on Intel openAPI Math Kernel Library (MKL) Pardiso","category":"page"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"note: Note\nUsing this solver requires adding the package Pardiso.jl, i.e. using Pardiso","category":"page"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"using Pardiso\nmkl_solver     = MKLPardisoFactorize()\nmkl_ite_solver = MKLPardisoIterate();\nnothing #hide","category":"page"},{"location":"examples/benchmark_LS_solvers/#Solving-Stationary-State","page":"LinearSolve solvers","title":"Solving Stationary State","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"Since we are using BenchmarkTools (@benchmark) in the following, we set verbose = false to disable the output message.","category":"page"},{"location":"examples/benchmark_LS_solvers/#UMFPACKFactorization-(Default-solver)-2","page":"LinearSolve solvers","title":"UMFPACKFactorization (Default solver)","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"@benchmark SteadyState(M_even; verbose = false)","category":"page"},{"location":"examples/benchmark_LS_solvers/#KLUFactorization-2","page":"LinearSolve solvers","title":"KLUFactorization","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"@benchmark SteadyState(M_even; solver = klu_solver, verbose = false)","category":"page"},{"location":"examples/benchmark_LS_solvers/#Julia's-built-in-generic-LU-factorization","page":"LinearSolve solvers","title":"Julia's built-in generic LU factorization","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"@benchmark SteadyState(M_even; solver = julia_solver, verbose = false)","category":"page"},{"location":"examples/benchmark_LS_solvers/#MKLPardisoFactorize","page":"LinearSolve solvers","title":"MKLPardisoFactorize","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"@benchmark SteadyState(M_even; solver = mkl_solver, verbose = false)","category":"page"},{"location":"examples/benchmark_LS_solvers/#MKLPardisoIterate","page":"LinearSolve solvers","title":"MKLPardisoIterate","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"@benchmark SteadyState(M_even; solver = mkl_ite_solver, verbose = false)","category":"page"},{"location":"examples/benchmark_LS_solvers/#Calculate-Spectrum","page":"LinearSolve solvers","title":"Calculate Spectrum","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/#UMFPACKFactorization-(Default-solver)-3","page":"LinearSolve solvers","title":"UMFPACKFactorization (Default solver)","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"@benchmark spectrum(M_odd, ados_s, d_up, ωlist; verbose = false)","category":"page"},{"location":"examples/benchmark_LS_solvers/#KLUFactorization-3","page":"LinearSolve solvers","title":"KLUFactorization","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"@benchmark spectrum(M_odd, ados_s, d_up, ωlist; solver = klu_solver, verbose = false)","category":"page"},{"location":"examples/benchmark_LS_solvers/#Julia's-built-in-LU-factorization-2","page":"LinearSolve solvers","title":"Julia's built-in LU factorization","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"@benchmark spectrum(M_odd, ados_s, d_up, ωlist; solver = julia_solver, verbose = false)","category":"page"},{"location":"examples/benchmark_LS_solvers/#MKLPardisoFactorize-2","page":"LinearSolve solvers","title":"MKLPardisoFactorize","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"@benchmark spectrum(M_odd, ados_s, d_up, ωlist; solver = mkl_solver, verbose = false)","category":"page"},{"location":"examples/benchmark_LS_solvers/#MKLPardisoIterate-2","page":"LinearSolve solvers","title":"MKLPardisoIterate","text":"","category":"section"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"@benchmark spectrum(M_odd, ados_s, d_up, ωlist; solver = mkl_ite_solver, verbose = false)","category":"page"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"","category":"page"},{"location":"examples/benchmark_LS_solvers/","page":"LinearSolve solvers","title":"LinearSolve solvers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"spectrum/#doc-Spectrum","page":"Spectrum","title":"Spectrum","text":"","category":"section"},{"location":"spectrum/#Introduction","page":"Spectrum","title":"Introduction","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"We briefly summarize how to numerically compute the spectrum associated with the system degree of freedom. Phys. Rev. Lett. 109, 266403 (2012) showed that the spectrum can be evaluated either in time or frequency domain.","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"HierarchicalEOM.jl provides a function spectrum which performs the calculation in frequency domain. There are two different methods (as shown below) which depends on the parity of the HEOMLS matrices hatmathcalM corresponds to different system degree of freedom. ","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"If you want to calculate the spectrum associated with","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"bosonic systems (Power Spectral Density) : you have to provide hatmathcalM constructed in :even parity.\nfermionic systems (Density of States) : you have to provide hatmathcalM constructed in :odd parity.","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"The function spectrum will automatically detect the parity of hatmathcalM by itself. Furthermore, the output of the function spectrum for both cases will always be in the type of Vector{Float64}, which contains the list of the spectrum values corresponding to the given ω_list.","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"HierarchicalEOM.jl wraps some of the functions in LinearSolve.jl, which is a very rich numerical library for solving the linear problems and provides many solvers. It offers quite a few options for the user to tailor the solver to their specific needs. The default solver (and its corresponding settings) are chosen to suit commonly encountered problems and should work fine for most of the cases. If you require more specialized methods, such as the choice of algorithm, please refer to benchmark for LinearSolve solvers and also the documentation of LinearSolve.jl.","category":"page"},{"location":"spectrum/#doc-PSD","page":"Spectrum","title":"Power Spectral Density","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"Start from the spectrum for bosonic systems (power spectral density) in the time-domain. We write the system two-time correlation function in terms of the propagator hatmathcalG(t)=exp(hatmathcalM t) for t0. The power spectral density S(omega) can be obtained as","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"beginaligned\npi S(omega) \n= textrmReleftint_0^infty dt langle a^dagger(t)a(0)rangle e^-iomega tright\n= textrmReleftint_0^infty dt langle a^dagger e^hatmathcalM tarangle e^-iomega tright\n= -textrmReleftlangle a^dagger (hatmathcalM -iomega)^-1 arangleright\n= -textrmRelefttextrmTrleft a^dagger (hatmathcalM -iomega)^-1 arho^(mn+)_textbfj vert textbfqrightright\nendaligned","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"where a half-Fourier transform has been introduced in the third line. We note that only the reduced density operator (m=n=0) is considered when taking the final trace operation.","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"The function spectrum solves the linear problem textbfA x=textbfb at a fixed frequency omega where ","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"textbfA=hatmathcalM-iomega\ntextbfb=arho^(mn+)_textbfj vert textbfq ","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"using the package LinearSolve.jl.","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"Finially, one can obtain the value of the power spectral density for specific omega, namely","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"pi S(omega) = -textrmRelefttextrmTrleft a^dagger textbfxrightright","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"See also the docstring : spectrum","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"M::AbstractHEOMMatrix # need to be in \":even\" parity\n\n# the input state can be in either type (but usually ADOs):\nρ::AbstractMatrix # the reduced density operator\nρ::ADOs # the ADOs solved from \"evolution\" or \"SteadyState\"\n\n# the (usually annihilation) operator \"a\" as shown above\na::AbstractMatrix \n\n# the spectrum value for the specific frequency ω which need to be solved\nω_list = 0:0.5:2 # [0.0, 0.5, 1.0, 1.5, 2.0]\n\nπSω = spectrum(M, ρ, a, ω_list)","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"note: Note\nTo calculate power spectral density, remember to construct hatmathcalM with :even parity.","category":"page"},{"location":"spectrum/#doc-DOS","page":"Spectrum","title":"Density of States","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"Start from the spectrum for fermionic systems (density of states) in the time-domain. We write the system two-time correlation function in terms of the propagator hatmathcalG(t)=exp(hatmathcalM t) for t0. The density of states A(omega) can be obtained as","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"beginaligned\npi A(omega) \n= textrmReleftint_0^infty dt langle d(t)d^dagger(0)rangle e^iomega tright + textrmReleftint_0^infty dt langle d^dagger(t)d(0)rangle e^-iomega tright\n= textrmReleftint_0^infty dt langle d e^hatmathcalM td^daggerrangle e^iomega tright+textrmReleftint_0^infty dt langle d^dagger e^hatmathcalM tdrangle e^-iomega tright\n= -textrmReleftlangle d (hatmathcalM +iomega)^-1 d^daggerrangle + langle d^dagger (hatmathcalM -iomega)^-1 drangleright\n= -textrmRelefttextrmTrleft d (hatmathcalM +iomega)^-1 d^daggerrho^(mn+)_textbfj vert textbfqright + textrmTrleft d^dagger (hatmathcalM -iomega)^-1 drho^(mn+)_textbfj vert textbfqrightright\nendaligned","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"where a half-Fourier transform has been introduced in the third line. We note that only the reduced density operator (m=n=0) is considered when taking the final trace operation.","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"The function spectrum solves two linear problems textbfA_+ textbfx_+=textbfb_+ and textbfA_- textbfx_-=textbfb_- at a fixed frequency omega where ","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"textbfA_+=hatmathcalM+iomega\ntextbfb_+=d^daggerrho^(mn+)_textbfj vert textbfq \ntextbfA_-=hatmathcalM-iomega\ntextbfb_-=drho^(mn+)_textbfj vert textbfq ","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"using the package LinearSolve.jl.","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"Finially, one can obtain the density of states for specific omega, namely","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"pi A(omega) = -textrmRelefttextrmTrleft d textbfx_+right+textrmTrleft d^dagger textbfx_-rightright","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"note: Odd-Parity for Density of States\nAs shown above, the HEOMLS matrix hatmathcalM acts on the :odd-parity space, compatibly with the parity of both the operators drho^(mn+)_textbfj vert textbfq and d^daggerrho^(mn+)_textbfj vert textbfq.   Therefore, remember to construct hatmathcalM with :odd parity for solving spectrum of fermionic systems.","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"See also the docstring : spectrum","category":"page"},{"location":"spectrum/","page":"Spectrum","title":"Spectrum","text":"Hs::AbstractMatrix # system Hamiltonian\nbath::FermionBath  # fermionic bath object\ntier::Int          # fermionic truncation level \n\n# create HEOMLS matrix in both :even and :odd parity\nM_even = M_Fermion(Hs, tier, bath) \nM_odd  = M_Fermion(Hs, tier, bath, :odd) \n\n# the input state can be in either type of density operator matrix or ADOs (but usually ADOs):\nados = SteadyState(M_even)\n\n# the (usually annihilation) operator \"d\" as shown above\nd::AbstractMatrix \n\n# the spectrum value for the specific frequency ω which need to be solved\nω_list = 0:0.5:2 # [0.0, 0.5, 1.0, 1.5, 2.0]\n\nπAω = spectrum(M_odd, ados, d, ω_list)","category":"page"},{"location":"bosonic_bath/#doc-Bosonic-Bath","page":"Bosonic Bath","title":"Bosonic Bath","text":"","category":"section"},{"location":"bosonic_bath/#Bosonic-Bath-Introduction","page":"Bosonic Bath","title":"Introduction","text":"","category":"section"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"The BosonBath object describes the interaction between the system (s) and a exterior bosonic environment (b), which can be modeled by","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"H_sb=V_ssum_k g_k (b_k + b_k^dagger)","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"in terms of the coupling strength g_k and the annihilation (creation) operator b_k (b_k^dagger) associated to the k-th mode of the bosonic environment. Here, V_s refers to the system-interaction operator. In particular, V_s must be a Hermitian operator which can act on both bosonic and fermionic systems degree of freedom. In the fermionic system case, V_s must have even parity to be compatible with charge conservation.","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"The effects of a bosonic environment (initially in thermal equilibrium and linearly coupled to the system) are completely encoded in the two-time correlation functions, namely","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"C(t_1 t_2)\n=frac12piint_0^infty domega J(omega)leftn(omega)e^iomega (t_1-t_2)+(n(omega)+1)e^-iomega (t_1-t_2)right","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"where J(omega) is the spectral density of the bath and n(omega)=exp(omegak_B T)-1^-1 represents the Bose-Einstein distribution.","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"A more practical representation can be found by expressing the correlation function as a sum of exponential terms (Exponent), namely","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"C(t_1 t_2)=sum_i eta_i e^-gamma_i (t_1-t_2)","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"This allows us to define an iterative procedure which leads to the hierarchical equations of motion (HEOM).","category":"page"},{"location":"bosonic_bath/#Methods","page":"Bosonic Bath","title":"Methods","text":"","category":"section"},{"location":"bosonic_bath/#Construct-BosonBath-(with-real-and-imaginary-parts-are-combined)","page":"Bosonic Bath","title":"Construct BosonBath (with real and imaginary parts are combined)","text":"","category":"section"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"One can construct the BosonBath object with the coupling operator Vs::AbstractMatrix and the two lists η::AbstractVector and γ::AbstractVector which corresponds to the exponential terms eta_i_i and gamma_i_i, respectively.","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"bath = BosonBath(Vs, η, γ)","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"warning: Warning\nHere, the length of η and γ should be the same.","category":"page"},{"location":"bosonic_bath/#Construct-BosonBath-(with-real-and-imaginary-parts-are-separated)","page":"Bosonic Bath","title":"Construct BosonBath (with real and imaginary parts are separated)","text":"","category":"section"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"When gamma_i neq gamma_i^*, a closed form for the HEOM can be obtained by further decomposing C(t_1 t_2) into its real (R) and imaginary (I) parts as","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"C(t_1 t_2)=sum_u=textrmRtextrmI(delta_u textrmR + idelta_u textrmI)C^u(t_1 t_2)","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"where delta is the Kronecker delta function and C^u(t_1 t_2)=sum_i eta_i^u exp(-gamma_i^u (t_1-t_2))","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"In this case, the BosonBath object can be constructed by the following method:","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"bath = BosonBath(Vs, η_real, γ_real, η_imag, γ_imag)","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"warning: Warning\nHere, the length of η_real and γ_real should be the same.   Also, the length of η_imag and γ_imag should be the same.","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"Here, η_real::AbstractVector, γ_real::AbstractVector, η_imag::AbstractVector and γ_imag::AbstractVector correspond to the exponential terms eta_i^textrmR_i, gamma_i^textrmR_i, eta_i^textrmI_i and gamma_i^textrmI_i, respectively.","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"note: Note\nInstead of analytically solving the correlation function C(t_1 t_2) to obtain a sum of exponential terms, one can also use the built-in functions (for different spectral densities J(omega) and spectral decomposition methods, which have been analytically solved by the developers already) listed in the end of this page. ","category":"page"},{"location":"bosonic_bath/#Print-Bosonic-Bath","page":"Bosonic Bath","title":"Print Bosonic Bath","text":"","category":"section"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"One can check the information of the BosonBath by the print function, for example:","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"print(bath)","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"BosonBath object with (system) dim = 2 and 4 exponential-expansion terms","category":"page"},{"location":"bosonic_bath/#Calculate-the-correlation-function","page":"Bosonic Bath","title":"Calculate the correlation function","text":"","category":"section"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"To check whether the exponential terms in the BosonBath is correct or not, one can call C(bath::BosonBath, tlist::AbstractVector) to calculate the correlation function C(t), where t=t_1-t_2:","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"c_list = C(bath, tlist)","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"Here, c_list is a list which contains the value of C(t) corresponds to the given time series tlist.","category":"page"},{"location":"bosonic_bath/#Methods-for-Exponent","page":"Bosonic Bath","title":"Methods for Exponent","text":"","category":"section"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"HierarchicalEOM.jl also supports users to access the specific exponential term with brakets []. This returns an Exponent object, which contains the corresponding value of eta_i and gamma_i:","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"e = bath[2] # the 2nd-term\nprint(e)","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"Bath Exponent with types = \"bRI\", operator size = (2, 2), η = 1.5922874021206546e-6 + 0.0im, γ = 0.3141645167860635 + 0.0im.","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"One can even obtain the Exponent with iterative method:","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"for e in bath\n    println(e)\nend","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"Bath Exponent with types = \"bRI\", operator size = (2, 2), η = 4.995832638723504e-5 - 2.5e-6im, γ = 0.005 + 0.0im.\n\nBath Exponent with types = \"bRI\", operator size = (2, 2), η = 1.5922874021206546e-6 + 0.0im, γ = 0.3141645167860635 + 0.0im.\n\nBath Exponent with types = \"bRI\", operator size = (2, 2), η = 1.0039844180003819e-6 + 0.0im, γ = 0.6479143347831898 + 0.0im.\n\nBath Exponent with types = \"bRI\", operator size = (2, 2), η = 3.1005439801387293e-6 + 0.0im, γ = 1.8059644711829272 + 0.0im.","category":"page"},{"location":"bosonic_bath/#Types-of-Exponent","page":"Bosonic Bath","title":"Types of Exponent","text":"","category":"section"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"The different types of the (bosonic-bath) Exponent:","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"\"bR\" : from real part of bosonic correlation function C^u=textrmR(t_1 t_2)\n\"bI\" : from imaginary part of bosonic correlation function C^u=textrmI(t_1 t_2)\n\"bRI\" : from combined (real and imaginary part) bosonic bath correlation function C(t_1 t_2)","category":"page"},{"location":"bosonic_bath/#Boson-Drude-Lorentz","page":"Bosonic Bath","title":"Drude-Lorentz Spectral Density","text":"","category":"section"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"J(omega)=frac4Delta Womegaomega^2+W^2","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"Here, Delta represents the coupling strength between system and the bosonic environment with band-width W.","category":"page"},{"location":"bosonic_bath/#Matsubara-Expansion","page":"Bosonic Bath","title":"Matsubara Expansion","text":"","category":"section"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"With Matsubara Expansion, the correlation function can be analytically solved and expressed as follows:","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"C(t_1 t_2)=sum_l=1^infty eta_l exp(-gamma_l (t_1-t_2))","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"with","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"beginaligned\ngamma_1 = W\neta_1 = Delta Wleft-i+cotleft(fracW2 k_B Tright)right\ngamma_lneq 1 = 2pi l k_B T\neta_lneq 1 = -2 k_B T cdot frac2Delta W cdot gamma_l-gamma_l^2 + W^2\nendaligned","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"This can be constructed by the built-in function Boson_DrudeLorentz_Matsubara:","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"Vs # coupling operator\nΔ  # coupling strength\nW  # band-width  of the environment\nT  # temperature of the environment\nN  # Number of exponential terms\nbath = Boson_DrudeLorentz_Matsubara(Vs, Δ, W, T, N - 1)","category":"page"},{"location":"bosonic_bath/#Padé-Expansion","page":"Bosonic Bath","title":"Padé Expansion","text":"","category":"section"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"With Padé Expansion, the correlation function can be analytically solved and expressed as the following exponential terms:","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"C(t_1 t_2)=sum_l=1^infty eta_l exp(-gamma_l (t_1-t_2))","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"with","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"beginaligned\ngamma_1 = W\neta_1 = Delta Wleft-i+cotleft(fracW2 k_B Tright)right\ngamma_lneq 1 = zeta_l k_B T\neta_lneq 1 = -2 kappa_l k_B T cdot frac2Delta W cdot zeta_l k_B T-(zeta_l k_B T)^2 + W^2\nendaligned","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"where the parameters kappa_l and zeta_l are described in J. Chem. Phys. 134, 244106 (2011). This can be constructed by the built-in function Boson_DrudeLorentz_Pade:","category":"page"},{"location":"bosonic_bath/","page":"Bosonic Bath","title":"Bosonic Bath","text":"Vs # coupling operator\nΔ  # coupling strength\nW  # band-width  of the environment\nT  # temperature of the environment\nN  # Number of exponential terms\nbath = Boson_DrudeLorentz_Pade(Vs, Δ, W, T, N - 1)","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"EditURL = \"../../../examples/benchmark_ODE_solvers.jl\"","category":"page"},{"location":"examples/benchmark_ODE_solvers/#benchmark-ODE-solvers","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"","category":"section"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"In this page, we will benchmark several solvers provided by DifferentialEquations.jl for solving time evolution in hierarchical equations of motion approach.","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"using OrdinaryDiffEq ## or \"using DifferentialEquations\"\nusing BenchmarkTools\nusing HierarchicalEOM\nHierarchicalEOM.versioninfo()","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"Here, we use the example of driven systems and dynamical decoupling:","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"Γ = 0.0005\nW = 0.005\nT = 0.05\nN = 3\ntier  = 6\namp   = 0.50\ndelay = 20\ntlist = 0:0.4:400\n\nσz = [1 0; 0 -1]\nσx = [0 1; 1  0]\nH0 = 0.0 * σz\nρ0 = 0.5 * [1 1; 1 1];\nparam = (amp, delay, σx)\n\nfunction pulse(V, Δ, t)\n    τ = 0.5 * π / V\n    period = τ + Δ\n\n    if (t % period) < τ\n        return V\n    else\n        return 0\n    end\nend\n\nfunction H_D(p::Tuple, t)\n    V, Δ, σx = p\n    return pulse(V, Δ, t) * σx\nend\n\nbath = Boson_DrudeLorentz_Pade(σz, Γ, W, T, N)\nM = M_Boson(H0, tier, bath);\nnothing #hide","category":"page"},{"location":"examples/benchmark_ODE_solvers/#ODE-Solver-List","page":"DifferentialEquations solvers","title":"ODE Solver List","text":"","category":"section"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"(click here to see the full solver list provided by DifferentialEquations.jl)","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"For any extra solver options, we can add it in the function evolution with keyword arguments. These keyword arguments will be directly pass to the solvers in DifferentialEquations (click here to see the documentation for the common solver options)","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"Furthermore, since we are using BenchmarkTools (@benchmark) in the following, we set verbose = false to disable the output message.","category":"page"},{"location":"examples/benchmark_ODE_solvers/#DP5-(Default-solver)","page":"DifferentialEquations solvers","title":"DP5 (Default solver)","text":"","category":"section"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"Dormand-Prince's 5/4 Runge-Kutta method. (free 4th order interpolant)","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"@benchmark evolution(M, ρ0, tlist, H_D, param; abstol = 1e-12, reltol = 1e-12, verbose = false)","category":"page"},{"location":"examples/benchmark_ODE_solvers/#RK4","page":"DifferentialEquations solvers","title":"RK4","text":"","category":"section"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"The canonical Runge-Kutta Order 4 method. Uses a defect control for adaptive stepping using maximum error over the whole interval.","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"@benchmark evolution(M, ρ0, tlist, H_D, param; solver = RK4(), abstol = 1e-12, reltol = 1e-12, verbose = false)","category":"page"},{"location":"examples/benchmark_ODE_solvers/#Tsit5","page":"DifferentialEquations solvers","title":"Tsit5","text":"","category":"section"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"Tsitouras 5/4 Runge-Kutta method. (free 4th order interpolant).","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"@benchmark evolution(M, ρ0, tlist, H_D, param; solver = Tsit5(), abstol = 1e-12, reltol = 1e-12, verbose = false)","category":"page"},{"location":"examples/benchmark_ODE_solvers/#Vern7","page":"DifferentialEquations solvers","title":"Vern7","text":"","category":"section"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"Verner's “Most Efficient” 7/6 Runge-Kutta method. (lazy 7th order interpolant).","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"@benchmark evolution(M, ρ0, tlist, H_D, param; solver = Vern7(), abstol = 1e-12, reltol = 1e-12, verbose = false)","category":"page"},{"location":"examples/benchmark_ODE_solvers/#Vern9","page":"DifferentialEquations solvers","title":"Vern9","text":"","category":"section"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"Verner's “Most Efficient” 9/8 Runge-Kutta method. (lazy 9th order interpolant)","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"@benchmark evolution(M, ρ0, tlist, H_D, param; solver = Vern9(), abstol = 1e-12, reltol = 1e-12, verbose = false)","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"","category":"page"},{"location":"examples/benchmark_ODE_solvers/","page":"DifferentialEquations solvers","title":"DifferentialEquations solvers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"hierarchy_dictionary/#doc-Hierarchy-Dictionary","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"","category":"section"},{"location":"hierarchy_dictionary/#Introduction","page":"Hierarchy Dictionary","title":"Introduction","text":"","category":"section"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"For hierarchical equations of motions, there are many indices the users have to deal with including the indices of the Exponent in bosonic baths, the Exponent in fermionic baths, and the ADOs formed by the hierarchy.","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"With the auxiliary density operators rho_textbfjverttextbfq^(mnp), we use the following keywords :","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"idx : the index of the auxiliary density operators\nlvl : the level m (n) of the bosonic (fermionic) hierarchy\nnvec : object Nvec which stores the number of existence for each multi-index ensemble j (q) in vector textbfj (textbfq).","category":"page"},{"location":"hierarchy_dictionary/#Dictionary-for-Pure-Bosonic-or-Fermionic-Baths","page":"Hierarchy Dictionary","title":"Dictionary for Pure Bosonic or Fermionic Baths","text":"","category":"section"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"An object which contains all dictionaries for pure (bosonic or fermionic) bath-ADOs hierarchy, defined as:","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"struct HierarchyDict <: AbstractHierarchyDict","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"HierarchyDict can be obtained from the field .hierarchy in M_Boson or M_Fermion, and it contains the following fields :","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"idx2nvec : Return the Nvec from a given index of ADO\nnvec2idx : Return the index of ADO from a given Nvec\nlvl2idx : Return the list of ADO-indices from a given hierarchy level\nbathPtr : Records the tuple (alpha k) for each position in Nvec, where alpha and k represents the k-th exponential-expansion term of the alpha-th bath.","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"# HEOMLS for bosonic baths\nM::M_Boson\nHDict = M.hierarchy\n\n# HEOMLS for fermionic baths\nM::M_Fermion\nHDict = M.hierarchy\n\n# obtain the nvec corresponds to 10-th ADO\nnvec = HDict.idx2nvec[10]\n\n# obtain the index of the ADO corresponds to the given nvec\nnvec::Nvec\nidx = HDict.nvec2idx[nvec]\n\n# obtain a list of indices which corresponds to all ADOs in 3rd-level of hierarchy\nidx_list = HDict.lvl2idx[3] ","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"HierarchicalEOM.jl also provides a function getIndexEnsemble(nvec, bathPtr) to obtain the index of the Exponent and it's corresponding index of bath:","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"# HEOMLS\nM::M_Boson\nM::Fermion\n\nHDict = M.hierarchy\n\n# auxiliary density operators\nados::ADOs\n\nfor (idx, ado) in enumerate(ados)\n    ado # the corresponding auxiliary density operator for idx\n\n    # obtain the nvec corresponds to ado\n    nvec = HDict.idx2nvec[idx]\n\n    for (α, k, n) in getIndexEnsemble(nvec, HDict.bathPtr)\n        α  # index of the bath\n        k  # the index of the exponential-expansion term in α-th bath\n        n  # the repetition number of the ensemble {α, k} in vector j (or q) in ADOs\n        exponent = M.bath[α][k]  # the k-th exponential-expansion term in α-th bath\n\n        # do some calculations you want\n    end\nend","category":"page"},{"location":"hierarchy_dictionary/#Dictionary-for-Mixed-Bosonic-and-Fermionic-Baths","page":"Hierarchy Dictionary","title":"Dictionary for Mixed Bosonic and Fermionic Baths","text":"","category":"section"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"An object which contains all dictionaries for mixed (bosonic and fermionic) bath-ADOs hierarchy, defined as:","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"struct MixHierarchyDict <: AbstractHierarchyDict","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"MixHierarchyDict can be obtained from the field .hierarchy in M_Boson_Fermion, and it contains the following fields :","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"idx2nvec : Return the tuple (Nvec_b, Nvec_f) from a given index of ADO, where b represents boson and f represents fermion\nnvec2idx : Return the index from a given tuple (Nvec_b, Nvec_f), where b represents boson and f represents fermion\nBlvl2idx : Return the list of ADO-indices from a given bosonic-hierarchy level\nFlvl2idx : Return the list of ADO-indices from a given fermionic-hierarchy level\nbosonPtr : Records the tuple (alpha k) for each position in Nvec_b, where alpha and k represents the k-th exponential-expansion term of the alpha-th bosonic bath.\nfermionPtr : Records the tuple (alpha k) for each position in Nvec_f, where alpha and k represents the k-th exponential-expansion term of the alpha-th fermionic bath.","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"# HEOMLS \nM::M_Boson_Fermion\nHDict = M.hierarchy\n\n# obtain the nvec(s) correspond to 10-th ADO\nnvec_b, nvec_f = HDict.idx2nvec[10]\n\n# obtain the index of the ADO corresponds to the given nvec\nnvec_b::Nvec\nnvec_f::Nvec\nidx = HDict.nvec2idx[(nvec_b, nvec_f)]\n\n# obtain a list of indices which corresponds to all ADOs in 3rd-bosonic-level of hierarchy\nidx_list = HDict.Blvl2idx[3] \n\n# obtain a list of indices which corresponds to all ADOs in 4rd-fermionic-level of hierarchy\nidx_list = HDict.Flvl2idx[4] ","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"HierarchicalEOM.jl also provides a function getIndexEnsemble(nvec, bathPtr) to obtain the index of the Exponent and it's corresponding index of bath:","category":"page"},{"location":"hierarchy_dictionary/","page":"Hierarchy Dictionary","title":"Hierarchy Dictionary","text":"# HEOMLS\nM::M_Boson_Fermion\n\nHDict = M.hierarchy\n\n# auxiliary density operators\nados::ADOs\n\nfor (idx, ado) in enumerate(ados)\n    ado # the corresponding auxiliary density operator for idx\n\n    # obtain the nvec(s) correspond to ado\n    nvec_b, nvec_f = HDict.idx2nvec[idx]\n\n    # bosonic bath indices\n    for (β, k, n) in getIndexEnsemble(nvec_b, HDict.bosonPtr)\n        β  # index of the bosonic bath\n        k  # the index of the exponential-expansion term in β-th bosonic bath\n        nb # the repetition number of the ensemble {β, k} in vector j in ADOs\n        exponent = M.Bbath[β][k]  # the k-th exponential-expansion term in β-th bosonic bath\n\n        # do some calculations you want\n    end\n\n    # fermionic bath indices\n    for (α, h, n) in getIndexEnsemble(nvec_f, HDict.fermionPtr)\n        α  # index of the fermionic bath\n        h  # the index of the exponential-expansion term in α-th fermionic bath\n        nf # the repetition number of the ensemble {α, h} in vector q in ADOs\n        exponent = M.Fbath[α][h]  # the h-th exponential-expansion term in α-th fermionic bath\n\n        # do some calculations you want\n    end\nend","category":"page"},{"location":"stationary_state/#doc-Stationary-State","page":"Stationary State","title":"Stationary State","text":"","category":"section"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"HierarchicalEOM.jl implements two different ways to calculate stationary states of all Auxiliary Density Operators (ADOs).","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"To solve the stationary state of the reduced state and also all the ADOs, you only need to call SteadyState. Different methods are implemented with different input parameters of the function which makes it easy to switch between different methods. The output of the function SteadyState for each methods will always be in the type of the auxiliary density operators ADOs.","category":"page"},{"location":"stationary_state/#Solve-with-[LinearSolve.jl](http://linearsolve.sciml.ai/stable/)","page":"Stationary State","title":"Solve with LinearSolve.jl","text":"","category":"section"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"The first method is implemented by solving the linear problem","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"0=hatmathcalMrho^(mnp)_textbfj vert textbfq(t)","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"HierarchicalEOM.jl wraps some of the functions in LinearSolve.jl, which is a very rich numerical library for solving the linear problems and provides many solvers. It offers quite a few options for the user to tailor the solver to their specific needs. The default solver (and its corresponding settings) are chosen to suit commonly encountered problems and should work fine for most of the cases. If you require more specialized methods, such as the choice of algorithm, please refer to benchmark for LinearSolve solvers and also the documentation of LinearSolve.jl.","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"See the docstring of this method:  ","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"SteadyState(M::AbstractHEOMMatrix)","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"# the HEOMLS matrix\nM::AbstractHEOMMatrix  \nados_steady = SteadyState(M)","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"warning: Unphysical solution\nThis method does not require an initial condition rho^(mnp)_textbfj vert textbfq(0). Although this method works for most of the cases, it does not guarantee that one can obtain a physical (or unique) solution. If there is any problem within the solution, please try the second method which solves with an initial condition, as shown below.","category":"page"},{"location":"stationary_state/#Solve-with-[DifferentialEquations.jl](https://diffeq.sciml.ai/stable/)","page":"Stationary State","title":"Solve with DifferentialEquations.jl","text":"","category":"section"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"The second method is implemented by solving the ordinary differential equation (ODE)","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"partial_trho^(mnp)_textbfj vert textbfq(t)=hatmathcalMrho^(mnp)_textbfj vert textbfq(t)","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"until finding a stationary solution.","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"HierarchicalEOM.jl wraps some of the functions in DifferentialEquations.jl, which is a very rich numerical library for solving the differential equations and provides many ODE solvers. It offers quite a few options for the user to tailor the solver to their specific needs. The default solver (and its corresponding settings) are chosen to suit commonly encountered problems and should work fine for most of the cases. If you require more specialized methods, such as the choice of algorithm, please refer to the documentation of DifferentialEquations.jl.","category":"page"},{"location":"stationary_state/#Given-the-initial-state-as-Density-Operator-(AbstractMatrix-type)","page":"Stationary State","title":"Given the initial state as Density Operator (AbstractMatrix type)","text":"","category":"section"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"See the docstring of this method:  ","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"SteadyState(M::AbstractHEOMMatrix, ρ0)","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"# the HEOMLS matrix\nM::AbstractHEOMMatrix  \n\n# the initial state of the system density operator\nρ0::AbstractMatrix\n\nados_steady = SteadyState(M, ρ0)","category":"page"},{"location":"stationary_state/#Given-the-initial-state-as-Auxiliary-Density-Operators","page":"Stationary State","title":"Given the initial state as Auxiliary Density Operators","text":"","category":"section"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"See the docstring of this method:   SteadyState(M::AbstractHEOMMatrix, ados::ADOs)","category":"page"},{"location":"stationary_state/","page":"Stationary State","title":"Stationary State","text":"# the HEOMLS matrix\nM::AbstractHEOMMatrix  \n\n# the initial state of the ADOs\nados::AbstractMatrix\n\nados_steady = SteadyState(M, ados)","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"EditURL = \"../../../examples/SIAM.jl\"","category":"page"},{"location":"examples/SIAM/#exp-SIAM","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"","category":"section"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"The investigation of the Kondo effect in single-impurity Anderson model is crucial as it serves both as a valuable testing ground for the theories of the Kondo effect and has the potential to lead to a better understanding of this intrinsic many-body phenomena.","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"using HierarchicalEOM\nimport Plots","category":"page"},{"location":"examples/SIAM/#Hamiltonian","page":"The single-impurity Anderson model","title":"Hamiltonian","text":"","category":"section"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"We consider a single-level electronic system [which can be populated by a spin-up (uparrow) or spin-down (downarrow) electron] coupled to a fermionic reservoir (textrmf). The total Hamiltonian is given by H_textrmT=H_textrms+H_textrmf+H_textrmsf, where each terms takes the form","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"beginaligned\nH_textrms  = epsilon left(d^dagger_uparrow d_uparrow + d^dagger_downarrow d_downarrow right) + Uleft(d^dagger_uparrow d_uparrow d^dagger_downarrow d_downarrowright)\nH_textrmf  =sum_sigma=uparrowdownarrowsum_kepsilon_sigmakc_sigmak^daggerc_sigmak\nH_textrmsf =sum_sigma=uparrowdownarrowsum_kg_kc_sigmak^daggerd_sigma + g_k^*d_sigma^daggerc_sigmak\nendaligned","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"Here, d_uparrow (d_downarrow) annihilates a spin-up (spin-down) electron in the system, epsilon is the energy of the electron, and U is the Coulomb repulsion energy for double occupation. Furthermore, c_sigmak (c_sigmak^dagger) annihilates (creates) an electron in the state k (with energy epsilon_sigmak) of the reservoir.","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"Now, we can construct the system Hamiltonian","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"ϵ = -5\nU = 10\nσm = [0 1; 0  0] ## σ-\nσz = [1 0; 0 -1] ## σz\nII = [1 0; 0  1] ## identity matrix\n\n# construct the annihilation operator for both spin-up and spin-down\n# (utilize Jordan–Wigner transformation)\nd_up = kron(     σm, II)\nd_dn = kron(-1 * σz, σm)\nHsys = ϵ * (d_up' * d_up + d_dn' * d_dn) + U * (d_up' * d_up * d_dn' * d_dn)","category":"page"},{"location":"examples/SIAM/#Construct-bath-objects","page":"The single-impurity Anderson model","title":"Construct bath objects","text":"","category":"section"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"We assume the fermionic reservoir to have a Lorentzian-shaped spectral density, and we utilize the Padé decomposition. Furthermore, the spectral densities depend on the following physical parameters:","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"the coupling strength Gamma between system and reservoirs\nthe band-width W\nthe temperature T\nthe chemical potential mu\nthe total number of exponentials for the reservoir 2(N + 1)","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"Γ = 2\nμ = 0\nW = 10\nT = 0.5\nN = 5\nbath_up = Fermion_Lorentz_Pade(d_up, Γ, μ, W, T, N)\nbath_dn = Fermion_Lorentz_Pade(d_dn, Γ, μ, W, T, N)\nbath_list = [bath_up, bath_dn]","category":"page"},{"location":"examples/SIAM/#Construct-HEOMLS-matrix","page":"The single-impurity Anderson model","title":"Construct HEOMLS matrix","text":"","category":"section"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"(see also HEOMLS Matrix for Fermionic Baths)","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"tier = 3\nM_even = M_Fermion(Hsys, tier, bath_list)\nM_odd  = M_Fermion(Hsys, tier, bath_list, :odd)","category":"page"},{"location":"examples/SIAM/#Solve-stationary-state-of-ADOs","page":"The single-impurity Anderson model","title":"Solve stationary state of ADOs","text":"","category":"section"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"(see also Stationary State)","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"ados_s = SteadyState(M_even)","category":"page"},{"location":"examples/SIAM/#Calculate-density-of-states-(DOS)","page":"The single-impurity Anderson model","title":"Calculate density of states (DOS)","text":"","category":"section"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"(see also Spectrum)","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"ωlist = -10:1:10\ndos = spectrum(M_odd, ados_s, d_up, ωlist)\n\nPlots.plot(ωlist, dos)","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"","category":"page"},{"location":"examples/SIAM/","page":"The single-impurity Anderson model","title":"The single-impurity Anderson model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"EditURL = \"../../../examples/cavityQED.jl\"","category":"page"},{"location":"examples/cavityQED/#Cavity-QED-system","page":"Cavity QED system","title":"Cavity QED system","text":"","category":"section"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"Cavity quantum electrodynamics (cavity QED) is an important topic for studying the interaction between atoms (or other particles) and light confined in a reflective cavity, under conditions where the quantum nature of photons is significant.","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"using HierarchicalEOM\nusing LaTeXStrings\nimport QuantumOptics, Plots","category":"page"},{"location":"examples/cavityQED/#Hamiltonian","page":"Cavity QED system","title":"Hamiltonian","text":"","category":"section"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"The Jaynes-Cummings model is a standard model in the realm of cavity QED. It illustrates the interaction between a two-level atom (textrmA) and a quantized single-mode within a cavity (textrmc).","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"beginaligned\nH_textrms=H_textrmA+H_textrmc+H_textrmint\nH_textrmA=fracomega_A2sigma_z\nH_textrmc=omega_textrmc a^dagger a\nH_textrmint=g (a^daggersigma^-+asigma^+)\nendaligned","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"where sigma^- (sigma^+) is the annihilation (creation) operator of the atom, and a (a^dagger) is the annihilation (creation) operator of the cavity.","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"Furthermore, we consider the system is coupled to a bosonic reservoir (textrmb). The total Hamiltonian is given by H_textrmTotal=H_textrms+H_textrmb+H_textrmsb, where H_textrmb and H_textrmsb takes the form","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"beginaligned\nH_textrmb    =sum_komega_kb_k^daggerb_k\nH_textrmsb   =(a+a^dagger)sum_kg_k(b_k + b_k^dagger)\nendaligned","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"Here, H_textrmb describes a bosonic reservoir where b_k (b_k^dagger) is the bosonic annihilation (creation) operator associated to the kth mode (with frequency omega_k). Also, H_textrmsb illustrates the interaction between the cavity and the bosonic reservoir.","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"Now, we can build the system Hamiltonian with the package QuantumOptics.jl (optional) to construct the operators.","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"note: Note\nNote that HierarchicalEOM.jl only accept standard julia bulit-in types. If you use QuantumOptics to construct the operators, remember that the matrix (or vector) in standard type are stored in .data field of the objects, i.e., op.data where op is a QuantumOptics-type object. Thus, you should take it as the inputs of HierarchicalEOM.jl for objects in QuantumOptics package.","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"N_photon = 2 ## We truncate the photon number of the system cavity to 2\nωA = 2\nωc = 2\ng  = 0.1\n\n# basis\na_basis = QuantumOptics.FockBasis(N_photon)\nb_spin  = QuantumOptics.SpinBasis(1//2)\n\n# operators\na_c  = QuantumOptics.destroy(a_basis)\nI_c  = QuantumOptics.identityoperator(a_basis)\nσz_A = QuantumOptics.sigmaz(b_spin)\nσm_A = QuantumOptics.sigmam(b_spin)\nI_A  = QuantumOptics.identityoperator(b_spin)\n\n# operators in tensor-space\na  = QuantumOptics.tensor(a_c, I_A)\nσz = QuantumOptics.tensor(I_c, σz_A)\nσm = QuantumOptics.tensor(I_c, σm_A)\n\n# Hamiltonian\nH_A   = 0.5 * ωA * σz\nH_c   =       ωc * a' * a\nH_int = g * ( a' * σm + a * σm' )\n\nH_s = H_A + H_c + H_int\n\n# initial state\nket0 = QuantumOptics.tensor(QuantumOptics.Ket(a_basis,[1,0,0]),QuantumOptics.Ket(b_spin,[1,0]))\nρ0   = QuantumOptics.tensor(ket0, ket0');\nnothing #hide","category":"page"},{"location":"examples/cavityQED/#Construct-bath-objects","page":"Cavity QED system","title":"Construct bath objects","text":"","category":"section"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"We assume the bosonic reservoir to have a Drude-Lorentz Spectral Density, and we utilize the Padé decomposition. Furthermore, the spectral densities depend on the following physical parameters:","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"the coupling strength Gamma between system and reservoir\nthe band-width W\nthe temperature T\nthe total number of exponentials for the reservoir (N + 1)","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"Γ = 0.01\nW = 1\nT = 0.025\nN = 20\nBath = Boson_DrudeLorentz_Pade((a + a').data, Γ, W, T, N)","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"Before incorporating the correlation function into the HEOMLS matrix, it is essential to verify if the total number of exponentials for the reservoir sufficiently describes the practical situation.","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"tlist_test = 0:0.1:10;\n\nBath_test = Boson_DrudeLorentz_Pade((a + a').data, Γ, W, T, 1000);\nCt  = C(Bath, tlist_test);\nCt2 = C(Bath_test, tlist_test);\n\nPlots.plot(tlist_test,  real(Ct),  label=\"N=20 (real part )\",  linestyle=:dash,  linewidth=3)\nPlots.plot!(tlist_test, real(Ct2), label=\"N=1000 (real part)\", linestyle=:solid, linewidth=3)\nPlots.plot!(tlist_test, imag(Ct),  label=\"N=20 (imag part)\",   linestyle=:dash,  linewidth=3)\nPlots.plot!(tlist_test, imag(Ct2), label=\"N=1000 (imag part)\", linestyle=:solid, linewidth=3)\n\nPlots.xaxis!(\"t\")\nPlots.yaxis!(\"C(t)\")","category":"page"},{"location":"examples/cavityQED/#Construct-HEOMLS-matrix","page":"Cavity QED system","title":"Construct HEOMLS matrix","text":"","category":"section"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"(see also HEOMLS Matrix for Bosonic Baths) Here, we consider an incoherent pumping to the atom, which can be described by an Lindblad dissipator (see here for more details).","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"Furthermore, we set the important threshold to be 1e-6.","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"pump   = 0.01\nJ_pump = sqrt(pump) * (σm').data\n\ntier = 2\nM_Heom = M_Boson(H_s.data, tier, threshold=1e-6, Bath)\nM_Heom = addBosonDissipator(M_Heom, J_pump)","category":"page"},{"location":"examples/cavityQED/#Solve-time-evolution-of-ADOs","page":"Cavity QED system","title":"Solve time evolution of ADOs","text":"","category":"section"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"(see also Time Evolution)","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"t_list = 0:1:500\nevo_H  = evolution(M_Heom, ρ0.data, t_list);\nnothing #hide","category":"page"},{"location":"examples/cavityQED/#Solve-stationary-state-of-ADOs","page":"Cavity QED system","title":"Solve stationary state of ADOs","text":"","category":"section"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"(see also Stationary State)","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"steady_H = SteadyState(M_Heom);\nnothing #hide","category":"page"},{"location":"examples/cavityQED/#Expectation-values","page":"Cavity QED system","title":"Expectation values","text":"","category":"section"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"observable of atom: sigma_z","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"σz_evo_H    = Expect(σz.data, evo_H)\nσz_steady_H = Expect(σz.data, steady_H)","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"observable of cavity: a^dagger a (average photon number)","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"np_evo_H    = Expect((a' * a).data, evo_H)\nnp_steady_H = Expect((a' * a).data, steady_H)\n\np1 = Plots.plot(\n    t_list,\n    [\n        σz_evo_H,\n        ones(length(t_list)).* σz_steady_H\n    ],\n    label=[L\"\\langle \\sigma_z \\rangle\"  L\"\\langle \\sigma_z \\rangle ~~(\\textrm{steady})\"],\n    linewidth=3,\n    linestyle=[:solid  :dash]\n)\np2 = Plots.plot(\n    t_list,\n    [\n        np_evo_H,\n        ones(length(t_list)).* np_steady_H\n    ],\n    label=[L\"\\langle a^\\dagger a \\rangle\"  L\"\\langle a^\\dagger a \\rangle ~~(\\textrm{steady})\"],\n    linewidth=3,\n    linestyle=[:solid  :dash]\n)\nPlots.plot(p1, p2, layout=[1,1])\nPlots.xaxis!(\"t\")","category":"page"},{"location":"examples/cavityQED/#Power-spectral-density","page":"Cavity QED system","title":"Power spectral density","text":"","category":"section"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"(see also Spectrum)","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"ω_list = 1:0.01:3\npsd_H = spectrum(M_Heom, steady_H, a.data, ω_list)\n\nPlots.plot(ω_list, psd_H, linewidth=3)\nPlots.xaxis!(L\"\\omega\")","category":"page"},{"location":"examples/cavityQED/#Compare-with-Master-Eq.-approach","page":"Cavity QED system","title":"Compare with Master Eq. approach","text":"","category":"section"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"(see also HEOMLS for Master Equations)","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"The Lindblad master equations which describs the cavity couples to an extra bosonic reservoir with Drude-Lorentzian spectrum density is given by","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"# Drude_Lorentzian spectral density\nDrude_Lorentz(ω, Γ, W) = 4 * Γ * W * ω / ( (ω)^2 + (W)^2 )\n\n# Bose-Einstein distribution\nn_b(ω, T) = 1 / (exp(ω / T) - 1)\n\n# build the jump operators\njump_op = [\n    sqrt(Drude_Lorentz(ωc, Γ, W) * (n_b(ωc, T) + 1)) * a.data,\n    sqrt(Drude_Lorentz(ωc, Γ, W) * (n_b(ωc, T)))     * (a').data,\n    J_pump\n];\n\n# construct the HEOMLS matrix for master equation\nM_master = M_S(H_s.data)\nM_master = addBosonDissipator(M_master, jump_op)\n\n# time evolution\nevo_M = evolution(M_master, ρ0.data, t_list);\n\n# steady\nsteady_M = SteadyState(M_master);\n\n# expectation value of σz\nσz_evo_M    = Expect(σz.data, evo_M)\nσz_steady_M = Expect(σz.data, steady_M)\n\n# average photon number\nnp_evo_M    = Expect((a' * a).data, evo_M)\nnp_steady_M = Expect((a' * a).data, steady_M)\n\np1 = Plots.plot(\n    t_list,\n    [\n        σz_evo_M,\n        ones(length(t_list)).* σz_steady_M\n    ],\n    label=[L\"\\langle \\sigma_z \\rangle\"  L\"\\langle \\sigma_z \\rangle ~~(\\textrm{steady})\"],\n    linewidth=3,\n    linestyle=[:solid  :dash],\n)\np2 = Plots.plot(\n    t_list,\n    [\n        np_evo_M,\n        ones(length(t_list)).* np_steady_M\n    ],\n    label=[L\"\\langle a^\\dagger a \\rangle\"  L\"\\langle a^\\dagger a \\rangle ~~(\\textrm{steady})\"],\n    linewidth=3,\n    linestyle=[:solid  :dash],\n)\nPlots.plot(p1, p2, layout=[1,1])\nPlots.xaxis!(\"t\")","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"We can also calculate the power spectral density","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"ω_list = 1:0.01:3\npsd_M = spectrum(M_master, steady_M, a.data, ω_list)\n\nPlots.plot(ω_list, psd_M, linewidth=3)\nPlots.xaxis!(L\"\\omega\")","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"Due to the weak coupling between the system and an extra bosonic environment, the Master equation's outcome is expected to be similar to the results obtained from the HEOM method.","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"","category":"page"},{"location":"examples/cavityQED/","page":"Cavity QED system","title":"Cavity QED system","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"EditURL = \"../../../examples/dynamical_decoupling.jl\"","category":"page"},{"location":"examples/dynamical_decoupling/#exp-dynamical-decoupling","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"","category":"section"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"In this page, we show how to solve the time evolution with time-dependent Hamiltonian problems in hierarchical equations of motion approach.","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"using HierarchicalEOM\nusing LaTeXStrings\nimport Plots","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"Here, we study dynamical decoupling which is a common tool used to undo the dephasing effect from the environment even for finite pulse duration.","category":"page"},{"location":"examples/dynamical_decoupling/#Hamiltonian","page":"Driven Systems and Dynamical Decoupling","title":"Hamiltonian","text":"","category":"section"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"We consider a two-level system coupled to a bosonic reservoir (textrmb). The total Hamiltonian is given by H_textrmT=H_textrms+H_textrmb+H_textrmsb, where each terms takes the form","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"beginaligned\nH_textrms(t) = H_0 + H_textrmD(t)\nH_0               = fracomega_02 sigma_z\nH_textrmb    =sum_komega_kb_k^daggerb_k\nH_textrmsb   =sigma_zsum_kg_alphak(b_k + b_k^dagger)\nendaligned","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"Here, H_textrmb describes a bosonic reservoir where b_k (b_k^dagger) is the bosonic annihilation (creation) operator associated to the kth mode (with frequency omega_k).","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"Furthermore, to observe the time evolution of the coherence, we consider the initial state to be","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"ψ(t=0)=frac1sqrt2left(0rangle+1rangleright)","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"ω0 = 0.\nσz = [1 0; 0 -1]\nσx = [0 1; 1  0]\nH0 = 0.5 * ω0 * σz\n\nρ0 = 0.5 * [1 1; 1 1];\nnothing #hide","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"The time-dependent driving term H_textrmD(t) has the form","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"H_textrmD(t) = sum_n=1^N f_n(t) sigma_x","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"where the pulse is chosen to have duration tau together with a delay Delta between each pulses, namely","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"f_n(t)\n= begincases\n  V  textrmif(n-1)tau + nDelta leq t leq n (tau + Delta)\n  0  textrmotherwise\n  endcases","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"Here, we set the period of the pulses to be tau V = pi2. Therefore, we consider two scenarios with fast and slow pulses:","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"# a function which returns the amplitude of the pulse at time t\nfunction pulse(V, Δ, t)\n    τ = 0.5 * π / V\n    period = τ + Δ\n\n    if (t % period) < τ\n        return V\n    else\n        return 0\n    end\nend\n\ntlist = 0:0.4:400\namp_fast = 0.50\namp_slow = 0.01\ndelay = 20\n\nPlots.plot(\n    tlist,\n    [\n        [pulse(amp_fast, delay, t) for t in tlist],\n        [pulse(amp_slow, delay, t) for t in tlist]\n    ],\n    label = [\"Fast Pulse\" \"Slow Pulse\"],\n    linestyle = [:solid :dash]\n)","category":"page"},{"location":"examples/dynamical_decoupling/#Construct-bath-objects","page":"Driven Systems and Dynamical Decoupling","title":"Construct bath objects","text":"","category":"section"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"We assume the bosonic reservoir to have a Drude-Lorentz Spectral Density, and we utilize the Padé decomposition. Furthermore, the spectral densities depend on the following physical parameters:","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"the coupling strength Gamma between system and reservoir\nthe band-width W\nthe temperature T\nthe total number of exponentials for the reservoir (N + 1)","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"Γ = 0.0005\nW = 0.005\nT = 0.05\nN = 3\nbath = Boson_DrudeLorentz_Pade(σz, Γ, W, T, N)","category":"page"},{"location":"examples/dynamical_decoupling/#Construct-HEOMLS-matrix","page":"Driven Systems and Dynamical Decoupling","title":"Construct HEOMLS matrix","text":"","category":"section"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"(see also HEOMLS Matrix for Bosonic Baths)","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"note: Note\nOnly provide the time-independent part of system Hamiltonian when constructing HEOMLS matrices (the time-dependent part should be given when solving the time evolution).","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"tier = 6\nM = M_Boson(H0, tier, bath)","category":"page"},{"location":"examples/dynamical_decoupling/#time-evolution-with-time-independent-Hamiltonian","page":"Driven Systems and Dynamical Decoupling","title":"time evolution with time-independent Hamiltonian","text":"","category":"section"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"(see also Time Evolution)","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"noPulseResult = evolution(M, ρ0, tlist);\nnothing #hide","category":"page"},{"location":"examples/dynamical_decoupling/#Solve-time-evolution-with-time-dependent-Hamiltonian","page":"Driven Systems and Dynamical Decoupling","title":"Solve time evolution with time-dependent Hamiltonian","text":"","category":"section"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"(see also Time Evolution)","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"We need to provide a user-defined function (named as H_D in this case), which must be in the form H_D(p::Tuple, t) and returns the time-dependent part of system Hamiltonian (in AbstractMatrix type) at any given time point t. The parameter p should be a Tuple which contains all the extra parameters [V (amplitude), Δ (delay), and σx (operator) in this case] for the function H_D:","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"function H_D(p::Tuple, t)\n    V, Δ, σx = p\n    return pulse(V, Δ, t) * σx\nend;\nnothing #hide","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"The parameter tuple p will be passed to your function H_D directly from the last required parameter in evolution:","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"fastTuple = (amp_fast, delay, σx)\nslowTuple = (amp_slow, delay, σx)\n\nfastPulseResult = evolution(M, ρ0, tlist, H_D, fastTuple);\nslowPulseResult = evolution(M, ρ0, tlist, H_D, slowTuple);\nnothing #hide","category":"page"},{"location":"examples/dynamical_decoupling/#Measure-the-coherence","page":"Driven Systems and Dynamical Decoupling","title":"Measure the coherence","text":"","category":"section"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"One can use the built-in function Expect to calculate the expectation value from a given observable and ADOs:","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"# Define the operator that measures the 0, 1 element of density matrix\nρ01 = [0 1; 0 0]\n\nPlots.plot(\n    tlist,\n    [\n        Expect(ρ01, fastPulseResult),\n        Expect(ρ01, slowPulseResult),\n        Expect(ρ01, noPulseResult)\n    ],\n    label = [\"Fast Pulse\" \"Slow Pulse\" \"no Pulse\"],\n    linestyle = [:solid :dot :dash],\n    linewidth=3,\n    xlabel=L\"t\",\n    ylabel=L\"\\rho_{01}\",\n    grid=false\n)","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"This example is from QuTiP-BoFiN paper : Phys. Rev. Research 5, 013181 (2023).","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"","category":"page"},{"location":"examples/dynamical_decoupling/","page":"Driven Systems and Dynamical Decoupling","title":"Driven Systems and Dynamical Decoupling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"heom_matrix/schrodinger_eq/#doc-M_S","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS Matrix for Schrödinger Equation","text":"","category":"section"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"The HEOM Liouvillian superoperator matrix with cutoff level of the hierarchy equals to 0: struct M_S <: AbstractHEOMMatrix ","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"This corresponds to the standard Schrodinger (Liouville-von Neumann) equation, namely","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"hatmathcalMcdot=-i leftH_s cdot right_-","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"where cdot cdot_- stands for commutator.","category":"page"},{"location":"heom_matrix/schrodinger_eq/#Construct-Matrix","page":"HEOMLS for Schrödinger Equation","title":"Construct Matrix","text":"","category":"section"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"To construct the HEOM matrix for Schrödinger Equation, one can call ","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"M_S(Hsys, parity) with the following parameters:","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"args (Arguments)","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"Hsys : The time-independent system Hamiltonian\nparity::Symbol : the parity label of the fermionic system. Defaults to :even.","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"kwargs (Keyword Arguments)","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"verbose::Bool : To display verbose output during the process or not. Defaults to true.","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"For example:","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"Hs::AbstractMatrix # system Hamiltonian\n\n# create HEOMLS matrix in both :even and :odd parity\nM_even = M_S(Hs) \nM_odd  = M_S(Hs, :odd) ","category":"page"},{"location":"heom_matrix/schrodinger_eq/#Fields","page":"HEOMLS for Schrödinger Equation","title":"Fields","text":"","category":"section"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"The fields of the structure M_S are as follows:","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"data : the sparse matrix of HEOM Liouvillian superoperator\ntier : the tier (cutoff level) for the hierarchy, which equals to 0 in this case\ndim : the dimension of system\nN : the number of total ADOs, which equals to 1 (only the reduced density operator) in this case\nsup_dim : the dimension of system superoperator\nparity : the parity label of the fermionic system","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"One obtain the value of each fields as follows:","category":"page"},{"location":"heom_matrix/schrodinger_eq/","page":"HEOMLS for Schrödinger Equation","title":"HEOMLS for Schrödinger Equation","text":"M::M_S\n\nM.data\nM.tier\nM.dim\nM.N\nM.sup_dim\nM.parity","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/#doc-M_Boson_Fermion","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS Matrix for Hybrid (Bosonic and Fermionic) Baths","text":"","category":"section"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"The HEOM Liouvillian superoperator matrix struct M_Boson_Fermion <: AbstractHEOMMatrix which describes the system simultaneously interacts with multiple Bosonic baths and Fermionic baths. ","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/#Construct-Matrix","page":"HEOMLS for Bosonic and Fermionic Bath","title":"Construct Matrix","text":"","category":"section"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"To construct the HEOM matrix in this case, one can call ","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"M_Boson_Fermion(Hsys, Btier, Ftier, Bbath, Fbath, parity) with the following parameters:","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"args (Arguments)","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"Hsys : The time-independent system Hamiltonian\nBtier::Int : the tier (cutoff level) for the bosonic bath\nFtier::Int : the tier (cutoff level) for the fermionic bath\nBbath::Vector{BosonBath} : objects for different bosonic baths\nFbath::Vector{FermionBath} : objects for different fermionic baths\nparity::Symbol : the parity label of the fermionic system. Defaults to :even.","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"kwargs (Keyword Arguments)","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"threshold::Real : The threshold of the importance value. Defaults to 0.0.\nverbose::Bool : To display verbose output and progress bar during the process or not. Defaults to true.","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"For example:","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"Hs::AbstractMatrix # system Hamiltonian\nBtier = 3\nFtier = 4\nBbath::BosonBath\nFbath::FermionBath\n\n# create HEOMLS matrix in both :even and :odd parity\nM_even = M_Fermion(Hs, Btier, Ftier, Bbath, Fbath) \nM_odd  = M_Fermion(Hs, Btier, Ftier, Bbath, Fbath, :odd) ","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/#Fields","page":"HEOMLS for Bosonic and Fermionic Bath","title":"Fields","text":"","category":"section"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"The fields of the structure M_Boson_Fermion are as follows:","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"data : the sparse matrix of HEOM Liouvillian superoperator\nBtier : the tier (cutoff level) for bosonic hierarchy\nFtier : the tier (cutoff level) for fermionic hierarchy\ndim : the dimension of system\nN : the number of total ADOs\nsup_dim : the dimension of system superoperator\nparity : the parity label of the fermionic system.\nBbath::Vector{BosonBath} : the vector which stores all BosonBath objects\nFbath::Vector{FermionBath} : the vector which stores all FermionBath objects\nhierarchy::MixHierarchyDict: the object which contains all dictionaries for mixed-bath-ADOs hierarchy.","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"One obtain the value of each fields as follows:","category":"page"},{"location":"heom_matrix/M_Boson_Fermion/","page":"HEOMLS for Bosonic and Fermionic Bath","title":"HEOMLS for Bosonic and Fermionic Bath","text":"M::M_Boson_Fermion\n\nM.data\nM.Btier\nM.Ftier\nM.dim\nM.N\nM.sup_dim\nM.parity\nM.Bbath\nM.Fbath\nM.hierarchy","category":"page"},{"location":"cite/#doc-Cite","page":"Cite HierarchicalEOM","title":"Cite HierarchicalEOM","text":"","category":"section"},{"location":"cite/","page":"Cite HierarchicalEOM","title":"Cite HierarchicalEOM","text":"@article{HierarchicalEOM-jl2023,\n  title={{HierarchicalEOM.jl}: {A}n efficient {J}ulia framework for hierarchical equations of motion in open quantum systems},\n  author={Huang, Yi-Te and Kuo, Po-Chen and Lambert, Neill and Cirio, Mauro and Cross, Simon and Yang, Shen-Liang and Nori, Franco and Chen, Yueh-Nan},\n  journal={arXiv preprint arXiv:2306.07522},\n  year={2023}\n}","category":"page"},{"location":"ADOs/#doc-ADOs","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"","category":"section"},{"location":"ADOs/#Introduction","page":"Auxiliary Density Operators","title":"Introduction","text":"","category":"section"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"The auxiliary density operators (ADOs) rho_textbfjverttextbfq^(mnp)(t) encode environmental effects related to different exponential terms (Exponent) present in the Bosonic Bath and Fermionic Bath correlation functions and provide an iterative description of high-order system-baths memory effects.","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"In rho_textbfjverttextbfq^(mnp)(t), the tuple (m n p) represents the mth-level-bosonic-and-nth-level-fermionic ADO with parity p, and textbfj (textbfq) denotes a vector j_mcdotsj_1 (q_ncdotsq_1) where each j (q) represents a specific multi-index ensemble beta l (alpha h) with","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"beta : denotes the index of bosonic bath\nalpha : denotes the index of fermionic bath\nl : denotes the index of exponent in the bosonic bath\nh : denotes the index of exponent in the fermionic bath","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"note: Reduced Density Operator\nThe system reduced density operator refers to m=n=0, namely rho_vert^(00p)(t).","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"In HierarchicalEOM.jl, we express all the auxiliary density operators into a single column vector and store it in the object defined as : ","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"struct ADOs, ","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"which is usually obtained after solving the time evolution or stationary state by a given HEOM Liouvillian Matrix.","category":"page"},{"location":"ADOs/#Fields","page":"Auxiliary Density Operators","title":"Fields","text":"","category":"section"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"The fields of the structure ADOs are as follows:","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"data : the vectorized auxiliary density operators\ndim : the dimension of the system\nN : the number of auxiliary density operators","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"One obtain the value of each fields as follows:","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"# usually obtained after solving time evolution or stationary state\nados::ADOs\n\nados.data\nados.dim\nados.N","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"warning: Warning\nWe express all the auxiliary density operators in only a single column vector ADOs.data. To obtain each auxiliary density operators in matrix form, please use the following methods and functions.","category":"page"},{"location":"ADOs/#Reduced-Density-Operator","page":"Auxiliary Density Operators","title":"Reduced Density Operator","text":"","category":"section"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"In order to obtain the system reduced density operator in matrix form, just simply call getRho","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"ados::ADOs\nρ = getRho(ados)","category":"page"},{"location":"ADOs/#High-Level-Auxiliary-Density-Operators","page":"Auxiliary Density Operators","title":"High-Level Auxiliary Density Operators","text":"","category":"section"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"Although we express all the auxiliary density operators in the vector ADOs.data, we still make the ADOs like a list where accessing each element would return a specific auxiliary density operator in matrix type. ","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"In order to obtain the auxiliary density operator in matrix form with a specific index i, just simply call getADO","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"ados::ADOs\ni::Int\n\nρ   = getADO(ados, 1) # the first element will always be the reduced density operator\nado = getADO(ados, i) # the i-th auxiliary density operator","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"Also, ADOs supports all the element-wise methods (functions) :","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"Supports length(::ADOs) which returns the total number of auxiliary density operators (same as ADOs.N) :","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"ados::ADOs\nlength(ados)","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"Supports bracket operation [] which is similar to access the element of a list :","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"ados::ADOs\n\n# all the following returned ADO will be in matrix form\nados[1]    # returns the first auxiliary density operator (which is always the reduced density operator)\nados[10]   # returns the 10-th auxiliary density operator\nados[3:10] # returns a list of auxiliary density operators from index 3 to 10\nados[end]  # returns the last auxiliary density operator","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"Supports iteration (for-loop) process :","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"ados::ADOs\n\nfor ado in ados  # iteration\n    ado # each auxiliary density operator in matrix form\nend","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"note: Work on high-level auxiliary density operators with Hierarchy Dictionary\nTo find the index of the auxiliary density operator and it's corresponding bath Exponent, please refer to Hierarchy Dictionary for more details.","category":"page"},{"location":"ADOs/#Expectation-Value","page":"Auxiliary Density Operators","title":"Expectation Value","text":"","category":"section"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"Given an observable A and ADOs rho^(mnp)_textbfj vert textbfq, one can calculate the expectation value by","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"langle A rangle = textrmTrleftA rho^(00p)_ vert right","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"where, m=n=0 represents the reduced density operator.","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"One can directly calculate the expectation values using the function Expect:","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"A::AbstractMatrix # observable\n\n# with a single ADOs\nados::ADOs\nE = Expect(A, ados)\n\n# with a list contains many ADOs\nados_list::Vector{ADOs}\nElist = Expect(A, ados_list)","category":"page"},{"location":"ADOs/","page":"Auxiliary Density Operators","title":"Auxiliary Density Operators","text":"Here, Elist contains the expectation values corresponding to the ados_list.","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"EditURL = \"../../../examples/quick_start.jl\"","category":"page"},{"location":"examples/quick_start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"examples/quick_start/#Content","page":"Quick Start","title":"Content","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"Import HierarchicalEOM.jl\nSystem and Bath\nHEOM Liouvillian superoperator\nTime Evolution\nStationary State\nReduced Density Operator\nExpectation Value\nMultiple Baths","category":"page"},{"location":"examples/quick_start/#Import-HierarchicalEOM.jl","page":"Quick Start","title":"Import HierarchicalEOM.jl","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"Here are the functions in HierarchicalEOM.jl that we will use in this tutorial (Quick Start):","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"import HierarchicalEOM\nimport HierarchicalEOM: Boson_DrudeLorentz_Pade, M_Boson, evolution, SteadyState, getRho, BosonBath, Expect","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"Note that you can also type using HierarchicalEOM to import everything you need in HierarchicalEOM.jl. To check the versions of dependencies of HierarchicalEOM.jl , run the following function","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"HierarchicalEOM.versioninfo()","category":"page"},{"location":"examples/quick_start/#System-and-Bath","page":"Quick Start","title":"System and Bath","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"Let us consider a simple two-level system coupled to a Drude-Lorentz bosonic bath. The system Hamiltonian, H_sys, and the bath spectral density, J_D, are","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"H_sys=fracepsilon sigma_z2 + fracDelta sigma_x2 textand","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"J_D(omega)=frac2lambda WomegaW^2+omega^2","category":"page"},{"location":"examples/quick_start/#System-Hamiltonian-and-initial-state","page":"Quick Start","title":"System Hamiltonian and initial state","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"You can construct system hamiltonian, initial state, and coupling operators by standard julia bulit-in types: Vector, SparseVector, Matrix, SparseMatrix.","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"Moreover, it is also convenient to use QuantumOptics framework. It provides many useful functions to create arbitrary quantum states and operators which can be combined in all the expected ways.","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"Note that HierarchicalEOM.jl only accept standard julia bulit-in types. If you use QuantumOptics to construct the operators, remember that the matrix (or vector) in standard type are stored in .data field of the objects, i.e., op.data where op is a QuantumOptics-type object. Thus, you should take it as the inputs of HierarchicalEOM.jl for objects in QuantumOptics package.","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"We demonstrate this tutorial by QuantumOptics:","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"import QuantumOptics: SpinBasis, sigmaz, sigmax, ⊗, Ket, Bra\n\nbasis = SpinBasis(1//2)\n\n# The system Hamiltonian\nϵ = 0.5 # energy of 2-level system\nΔ = 1.0 # tunneling term\n\nHsys = 0.5 * ϵ * sigmaz(basis) + 0.5 * Δ * sigmax(basis)\n\n# System initial state\nρ0 = Ket(basis, [1, 0]) ⊗ Bra(basis, [1, 0]);\nnothing #hide","category":"page"},{"location":"examples/quick_start/#Bath-Properties","page":"Quick Start","title":"Bath Properties","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"Now, we demonstrate how to describe the bath using the built-in implementation of J_D(omega) under Pade expansion by calling Boson_DrudeLorentz_Pade","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"λ = 0.1  # coupling strength\nW = 0.5  # cut-off frequency\nT = 0.5  # temperature\n\nQ = sigmaz(basis) # system-bath coupling operator\n\nN = 2 # Number of expansion terms to retain:\n\n# Padé expansion:\n# Remember to give the operator in Standard matrix (AbstractMatrix) type\n# That is, if using QuantumOptics package, give system coupling operator as Q.data\nbath = Boson_DrudeLorentz_Pade(Q.data, λ, W, T, N)","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"For other different expansions of the different spectral density correlation functions, please refer to Bosonic Bath and Fermionic Bath.","category":"page"},{"location":"examples/quick_start/#HEOM-Liouvillian-superoperator","page":"Quick Start","title":"HEOM Liouvillian superoperator","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"For bosonic bath, we can construct the HEOM Liouvillian superoperator matrix by calling M_Boson","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"# maximum tier of hierarchy\ntier = 5\n\n# Remember to give the operator in Standard matrix (AbstractMatrix) type\n# That is, if using QuantumOptics package, give system hamiltonian as Hsys.data\nL = M_Boson(Hsys.data, tier, bath)","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"To learn more about the HEOM Liouvillian superoperator matrix (including other types: M_Fermion, M_Boson_Fermion), please refer to HEOMLS Matrices.","category":"page"},{"location":"examples/quick_start/#Time-Evolution","page":"Quick Start","title":"Time Evolution","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"Next, we can calculate the time evolution for the entire auxiliary density operators (ADOs) by calling evolution","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"tlist = 0:0.2:50\nados_list = evolution(L, ρ0.data, tlist);\nnothing #hide","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"To learn more about evolution, please refer to Time Evolution.","category":"page"},{"location":"examples/quick_start/#Stationary-State","page":"Quick Start","title":"Stationary State","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"We can also solve the stationary state of the auxiliary density operators (ADOs) by calling SteadyState.","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"ados_steady = SteadyState(L)","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"To learn more about SteadyState, please refer to Stationary State.","category":"page"},{"location":"examples/quick_start/#Reduced-Density-Operator","page":"Quick Start","title":"Reduced Density Operator","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"To obtain the reduced density operator, one can either access the first element of auxiliary density operator (ADOs) or call getRho:","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"# reduce density operator in third time step of the evolution\nρ = ados_list[3][1]\nρ = getRho(ados_list[3])\n\n# reduce density operator in stationary state\nρ = ados_steady[1]\nρ = getRho(ados_steady);\nnothing #hide","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"One of the great features of HierarchicalEOM.jl is that we allow users to not only considering the density operator of the reduced state but also easily take high-order terms into account without struggling in finding the indices (see Auxiliary Density Operators and Hierarchy Dictionary for more details).","category":"page"},{"location":"examples/quick_start/#Expectation-Value","page":"Quick Start","title":"Expectation Value","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"We can now compare the results obtained from evolution and SteadyState:","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"# Define the operators that measure the populations of the two\n# system states:\nP00 = Ket(basis, [1, 0]) ⊗ Bra(basis, [1, 0])\nP11 = Ket(basis, [0, 1]) ⊗ Bra(basis, [0, 1])\n\n# Define the operator that measures the 0, 1 element of density matrix\n# (corresponding to coherence):\nP01 = Ket(basis, [1, 0]) ⊗ Bra(basis, [0, 1])\n\n# for steady state\np00_s = Expect(P00.data, ados_steady)\np01_s = Expect(P01.data, ados_steady)\n\n# for time evolution\np00_e = Expect(P00.data, ados_list)\np01_e = Expect(P01.data, ados_list);\nnothing #hide","category":"page"},{"location":"examples/quick_start/#Plot-the-results","page":"Quick Start","title":"Plot the results","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"using Plots, LaTeXStrings\n\nplot(tlist, p00_e, label = L\"\\textrm{P}_{00}\", linecolor=:blue, linestyle=:solid, linewidth=3, grid=false)\nplot!(tlist, p01_e, label = L\"\\textrm{P}_{01}\", linecolor=:red, linestyle=:solid, linewidth=3)\nplot!(tlist, ones(length(tlist)) .* p00_s, label = L\"\\textrm{P}_{00} \\textrm{(Steady State)}\", linecolor=:blue, linestyle=:dash, linewidth=3)\nplot!(tlist, ones(length(tlist)) .* p01_s, label = L\"\\textrm{P}_{01} \\textrm{(Steady State)}\", linecolor=:red, linestyle=:dash, linewidth=3)\n\nxlabel!(\"time\")\nylabel!(\"Population\")","category":"page"},{"location":"examples/quick_start/#Multiple-Baths","page":"Quick Start","title":"Multiple Baths","text":"","category":"section"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"HierarchicalEOM.jl also supports for system to interact with multiple baths.","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"All you need to do is to provide a list of baths instead of a single bath","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"Note that, for the following, we use the built-in linear algebra in Julia (instead of QuantumOptics.jl) to construct the operators","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"# The system Hamiltonian\nHsys = [\n    0.25 1.50 2.50;\n    1.50 0.75 3.50;\n    2.50 3.50 1.25\n]\n\n# System initial state\nρ0 = [\n    1 0 0;\n    0 0 0;\n    0 0 0\n];\n\n# Construct one bath for each system state:\n# note that `BosonBath[]` make the list created in type: Vector{BosonBath}\nbaths = BosonBath[]\nfor i in 1:3\n    # system-bath coupling operator: |i><i|\n    Q = zeros(3, 3)\n    Q[i, i] = 1\n\n    push!(baths, Boson_DrudeLorentz_Pade(Q, λ, W, T, N))\nend\n\nL = M_Boson(Hsys, tier, baths)\n\ntlist = 0:0.025:5\nados_list = evolution(L, ρ0, tlist)\n\n# Projector for each system state:\nP00 = [1 0 0; 0 0 0; 0 0 0]\nP11 = [0 0 0; 0 1 0; 0 0 0]\nP22 = [0 0 0; 0 0 0; 0 0 1]\n\n# calculate population for each system state:\np0 = Expect(P00, ados_list)\np1 = Expect(P11, ados_list)\np2 = Expect(P22, ados_list)\n\nplot(tlist, p0, linewidth=3, linecolor=\"blue\", label=L\"P_0\", grid=false)\nplot!(tlist, p1, linewidth=3, linecolor=\"orange\", label=L\"P_1\")\nplot!(tlist, p2, linewidth=3, linecolor=:green, label=L\"P_2\")\nxlabel!(\"time\")\nylabel!(\"Population\")","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"Note that this example can also be found in qutip documentation.","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"examples/quick_start/","page":"Quick Start","title":"Quick Start","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#HierarchicalEOM.jl:-An-efficient-Julia-framework-for-Hierarchical-Equations-of-Motion-(HEOM)-in-open-quantum-systems","page":"Introduction","title":"HierarchicalEOM.jl: An efficient Julia framework for Hierarchical Equations of Motion (HEOM) in open quantum systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"HierarchicalEOM.jl is a numerical framework written in Julia. It provides a user-friendly and efficient tool based on hierarchical equations of motion (HEOM) approach to simulate complex open quantum systems, including non-Markovian effects due to non-perturbative interaction with one (or multiple) environment(s). It is inspired by the Quantum Toolbox in Python (QuTiP).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"While integrating many of the features present in other open-source HEOM packages, HierarchicalEOM.jl also includes new functionalities, such as the construction of even- and odd-parity HEOM Liouvillian superoperator (HEOMLS) matrices, the estimation of importance values for all auxiliary density operators (ADOs), and the calculation of spectra for both bosonic and fermionic systems. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"By wrapping some functions from other Julia packages (DifferentialEquations.jl, LinearSolve.jl and fastExpm.jl), HierarchicalEOM.jl collects different methods and could further optimize the computation for the stationary state, and the time evolution of all ADOs. The required handling of the ADOs multi-indexes is achieved through a user-friendly interface called Hierarchy Dictionary.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: HEOM Ecosystem)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We believe that HierarchicalEOM.jl will be a valuable tool for researchers working in different fields such as quantum biology, quantum optics, quantum thermodynamics, quantum information, quantum transport, and condensed matter physics.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you like HierarchicalEOM.jl and find the framework useful in your research, we would be grateful if you could cite our publication ( arXiv:2306.07522  ) using the bibtex entry here.","category":"page"}]
}
